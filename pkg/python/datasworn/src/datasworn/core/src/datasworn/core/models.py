# generated by datamodel-codegen:
#   filename:  datasworn.schema.json
<<<<<<< HEAD
#   timestamp: 2025-12-27T19:03:54+00:00
=======
#   timestamp: 2026-01-23T12:06:33+00:00
>>>>>>> upstream/main

from __future__ import annotations

from datetime import date as date_aliased
from enum import Enum
from typing import Annotated, Any, Literal

<<<<<<< HEAD
from pydantic import AnyUrl, BaseModel, ConfigDict, EmailStr, Field, RootModel


class ActionRollMethod(Enum):
    miss = "miss"
    weak_hit = "weak_hit"
    strong_hit = "strong_hit"
    player_choice = "player_choice"
    highest = "highest"
    lowest = "lowest"
    all = "all"


class FieldType(Enum):
    clock = "clock"
    counter = "counter"
    checkbox = "checkbox"
    text = "text"
=======
from pydantic import Discriminator, AnyUrl, BaseModel, ConfigDict, EmailStr, Field, RootModel


class ActionRollMethod(Enum):
    miss = 'miss'
    weak_hit = 'weak_hit'
    strong_hit = 'strong_hit'
    player_choice = 'player_choice'
    highest = 'highest'
    lowest = 'lowest'
    all = 'all'


class FieldType(Enum):
    clock = 'clock'
    counter = 'counter'
    checkbox = 'checkbox'
    text = 'text'
>>>>>>> upstream/main


class AssetAbilityControlField(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    field_type: FieldType


<<<<<<< HEAD
class AssetAbilityId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an AssetAbility object.",
            pattern="^asset\\.ability:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)$",
            title="AssetAbilityId",
=======
AssetAbilityId = Annotated[
        str,
        Field(
            description='A unique ID representing an AssetAbility object.',
            pattern='^asset\\.ability:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)$',
            title='AssetAbilityId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetAbilityIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AssetAbilityId that can be used to match multiple AssetAbility objects.",
            pattern="^asset\\.ability:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)$",
            title="AssetAbilityIdWildcard",
=======
AssetAbilityIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetAbilityId that can be used to match multiple AssetAbility objects.',
            pattern='^asset\\.ability:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)$',
            title='AssetAbilityIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetAbilityMoveId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an AssetAbilityMove object.",
            pattern="^asset\\.ability\\.move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$",
            title="AssetAbilityMoveId",
=======
AssetAbilityMoveConditionId = Annotated[
        str,
        Field(
            description='A unique ID representing an AssetAbilityMoveCondition object.',
            pattern='^asset\\.ability\\.move\\.condition:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+)$',
            title='AssetAbilityMoveConditionId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetAbilityMoveIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AssetAbilityMoveId that can be used to match multiple AssetAbilityMove objects.",
            pattern="^asset\\.ability\\.move:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)$",
            title="AssetAbilityMoveIdWildcard",
=======
AssetAbilityMoveConditionIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetAbilityMoveConditionId that can be used to match multiple AssetAbilityMoveCondition objects.',
            pattern='^asset\\.ability\\.move\\.condition:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+|\\*)$',
            title='AssetAbilityMoveConditionIdWildcard',
        ),
    ]


AssetAbilityMoveId = Annotated[
        str,
        Field(
            description='A unique ID representing an AssetAbilityMove object.',
            pattern='^asset\\.ability\\.move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$',
            title='AssetAbilityMoveId',
        ),
    ]


AssetAbilityMoveIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetAbilityMoveId that can be used to match multiple AssetAbilityMove objects.',
            pattern='^asset\\.ability\\.move:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)$',
            title='AssetAbilityMoveIdWildcard',
        ),
    ]


AssetAbilityMoveOutcomeId = Annotated[
        str,
        Field(
            description='A unique ID representing an AssetAbilityMoveOutcome object.',
            pattern='^asset\\.ability\\.move\\.outcome:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)\\.([a-z][a-z0-9_]*|\\*)$',
            title='AssetAbilityMoveOutcomeId',
        ),
    ]


AssetAbilityMoveOutcomeIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetAbilityMoveOutcomeId that can be used to match multiple AssetAbilityMoveOutcome objects.',
            pattern='^asset\\.ability\\.move\\.outcome:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)\\.([a-z][a-z0-9_]*|\\*)$',
            title='AssetAbilityMoveOutcomeIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class FieldType1(Enum):
<<<<<<< HEAD
    text = "text"
=======
    text = 'text'
>>>>>>> upstream/main


class AssetAbilityOptionField(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    field_type: FieldType1


<<<<<<< HEAD
class AssetAbilityOracleRollableId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an AssetAbilityOracleRollable object.",
            pattern="^asset\\.ability\\.oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$",
            title="AssetAbilityOracleRollableId",
=======
AssetAbilityOracleRollableId = Annotated[
        str,
        Field(
            description='A unique ID representing an AssetAbilityOracleRollable object.',
            pattern='^asset\\.ability\\.oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$',
            title='AssetAbilityOracleRollableId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetAbilityOracleRollableIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AssetAbilityOracleRollableId that can be used to match multiple AssetAbilityOracleRollable objects.",
            pattern="^asset\\.ability\\.oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)$",
            title="AssetAbilityOracleRollableIdWildcard",
=======
AssetAbilityOracleRollableIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetAbilityOracleRollableId that can be used to match multiple AssetAbilityOracleRollable objects.',
            pattern='^asset\\.ability\\.oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)$',
            title='AssetAbilityOracleRollableIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetAbilityOracleRollableRowId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an AssetAbilityOracleRollableRow object.",
            pattern="^asset\\.ability\\.oracle_rollable\\.row:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+)$",
            title="AssetAbilityOracleRollableRowId",
=======
AssetAbilityOracleRollableRowId = Annotated[
        str,
        Field(
            description='A unique ID representing an AssetAbilityOracleRollableRow object.',
            pattern='^asset\\.ability\\.oracle_rollable\\.row:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+)$',
            title='AssetAbilityOracleRollableRowId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetAbilityOracleRollableRowIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AssetAbilityOracleRollableRowId that can be used to match multiple AssetAbilityOracleRollableRow objects.",
            pattern="^asset\\.ability\\.oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+|\\*)$",
            title="AssetAbilityOracleRollableRowIdWildcard",
=======
AssetAbilityOracleRollableRowIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetAbilityOracleRollableRowId that can be used to match multiple AssetAbilityOracleRollableRow objects.',
            pattern='^asset\\.ability\\.oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+|\\*)$',
            title='AssetAbilityOracleRollableRowIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class Max(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description="Null if there's no upper limit to the number of attached assets.",
            ge=1,
        ),
<<<<<<< HEAD
    ]


class AssetCollectionId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an AssetCollection object.",
            pattern="^asset_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$",
            title="AssetCollectionId",
=======
    ] = None


AssetCollectionId = Annotated[
        str,
        Field(
            description='A unique ID representing an AssetCollection object.',
            pattern='^asset_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='AssetCollectionId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetCollectionIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AssetCollectionId that can be used to match multiple AssetCollection objects.",
            pattern="^asset_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$",
            title="AssetCollectionIdWildcard",
=======
AssetCollectionIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetCollectionId that can be used to match multiple AssetCollection objects.',
            pattern='^asset_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$',
            title='AssetCollectionIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class FieldType2(Enum):
<<<<<<< HEAD
    checkbox = "checkbox"
    card_flip = "card_flip"
=======
    checkbox = 'checkbox'
    card_flip = 'card_flip'
>>>>>>> upstream/main


class AssetConditionMeterControlField(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    field_type: FieldType2


class AssetConditionMeterEnhancement(BaseModel):
<<<<<<< HEAD
    field_type: Literal["condition_meter"]
    max: Annotated[int, Field(description="The maximum value of this meter.")]


class FieldType3(Enum):
    condition_meter = "condition_meter"
    select_enhancement = "select_enhancement"
    checkbox = "checkbox"
    card_flip = "card_flip"
=======
    field_type: Literal['condition_meter']
    max: Annotated[int, Field(description='The maximum value of this meter.')]


class FieldType3(Enum):
    condition_meter = 'condition_meter'
    select_enhancement = 'select_enhancement'
    checkbox = 'checkbox'
    card_flip = 'card_flip'
>>>>>>> upstream/main


class AssetControlField(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    field_type: FieldType3


class FieldType4(Enum):
<<<<<<< HEAD
    condition_meter = "condition_meter"
=======
    condition_meter = 'condition_meter'
>>>>>>> upstream/main


class AssetControlFieldEnhancement(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    field_type: FieldType4


<<<<<<< HEAD
class AssetId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an Asset object.",
            pattern="^asset:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$",
            title="AssetId",
=======
AssetId = Annotated[
        str,
        Field(
            description='A unique ID representing an Asset object.',
            pattern='^asset:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='AssetId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AssetIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AssetId that can be used to match multiple Asset objects.",
            pattern="^asset:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$",
            title="AssetIdWildcard",
=======
AssetIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetId that can be used to match multiple Asset objects.',
            pattern='^asset:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$',
            title='AssetIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class FieldType5(Enum):
<<<<<<< HEAD
    select_value = "select_value"
    select_enhancement = "select_enhancement"
    text = "text"
=======
    select_value = 'select_value'
    select_enhancement = 'select_enhancement'
    text = 'text'
>>>>>>> upstream/main


class AssetOptionField(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    field_type: FieldType5


<<<<<<< HEAD
class AtlasCollectionId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an AtlasCollection object.",
            pattern="^atlas_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$",
            title="AtlasCollectionId",
=======
AtlasCollectionId = Annotated[
        str,
        Field(
            description='A unique ID representing an AtlasCollection object.',
            pattern='^atlas_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='AtlasCollectionId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AtlasCollectionIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AtlasCollectionId that can be used to match multiple AtlasCollection objects.",
            pattern="^atlas_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$",
            title="AtlasCollectionIdWildcard",
=======
AtlasCollectionIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AtlasCollectionId that can be used to match multiple AtlasCollection objects.',
            pattern='^atlas_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$',
            title='AtlasCollectionIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AtlasEntryId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an AtlasEntry object.",
            pattern="^atlas_entry:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$",
            title="AtlasEntryId",
=======
AtlasEntryId = Annotated[
        str,
        Field(
            description='A unique ID representing an AtlasEntry object.',
            pattern='^atlas_entry:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='AtlasEntryId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AtlasEntryIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded AtlasEntryId that can be used to match multiple AtlasEntry objects.",
            pattern="^atlas_entry:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$",
            title="AtlasEntryIdWildcard",
=======
AtlasEntryIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AtlasEntryId that can be used to match multiple AtlasEntry objects.',
            pattern='^atlas_entry:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$',
            title='AtlasEntryIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class ChallengeRank(Enum):
    int_1 = 1
    int_2 = 2
    int_3 = 3
    int_4 = 4
    int_5 = 5


class CollectableType(Enum):
<<<<<<< HEAD
    atlas_entry = "atlas_entry"
    npc = "npc"
    oracle_rollable = "oracle_rollable"
    asset = "asset"
    move = "move"


class CollectionType(Enum):
    atlas_collection = "atlas_collection"
    npc_collection = "npc_collection"
    oracle_collection = "oracle_collection"
    asset_collection = "asset_collection"
    move_category = "move_category"
=======
    atlas_entry = 'atlas_entry'
    npc = 'npc'
    oracle_rollable = 'oracle_rollable'
    asset = 'asset'
    move = 'move'


class CollectionType(Enum):
    atlas_collection = 'atlas_collection'
    npc_collection = 'npc_collection'
    oracle_collection = 'oracle_collection'
    asset_collection = 'asset_collection'
    move_category = 'move_category'
>>>>>>> upstream/main


class CoreTags(BaseModel):
    supernatural: Annotated[
        bool | None,
        Field(
<<<<<<< HEAD
            description="This object is supernatural in nature, and is ideal for settings that feature supernatural or mythic powers."
=======
            description='This object is supernatural in nature, and is ideal for settings that feature supernatural or mythic powers.'
>>>>>>> upstream/main
        ),
    ] = None
    technological: Annotated[
        bool | None,
        Field(
<<<<<<< HEAD
            description="This object is technological in nature, and is ideal for settings that feature remarkable technologies."
=======
            description='This object is technological in nature, and is ideal for settings that feature remarkable technologies.'
>>>>>>> upstream/main
        ),
    ] = None
    requires_allies: Annotated[
        bool | None,
        Field(
<<<<<<< HEAD
            description="This object requires allies to function, and is intended for co-op play, or guided play with allies. It is not appropriate for solo play."
=======
            description='This object requires allies to function, and is intended for co-op play, or guided play with allies. It is not appropriate for solo play.'
>>>>>>> upstream/main
        ),
    ] = None


<<<<<<< HEAD
class CssColor(RootModel[str]):
    root: Annotated[str, Field(description="A CSS color value.", title="CssColor")]


class Denizens(BaseModel):
    pass


class DelveSiteDenizenFrequency(Enum):
    very_common = "very_common"
    common = "common"
    uncommon = "uncommon"
    rare = "rare"
    unforeseen = "unforeseen"


class DelveSiteDenizenId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSiteDenizen object.",
            pattern="^delve_site\\.denizen:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$",
            title="DelveSiteDenizenId",
=======
class DelveSiteDenizenFrequency(Enum):
    very_common = 'very_common'
    common = 'common'
    uncommon = 'uncommon'
    rare = 'rare'
    unforeseen = 'unforeseen'


DelveSiteDenizenId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSiteDenizen object.',
            pattern='^delve_site\\.denizen:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteDenizenId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteDenizenIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteDenizenId that can be used to match multiple DelveSiteDenizen objects.",
            pattern="^delve_site\\.denizen:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$",
            title="DelveSiteDenizenIdWildcard",
=======
DelveSiteDenizenIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteDenizenId that can be used to match multiple DelveSiteDenizen objects.',
            pattern='^delve_site\\.denizen:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$',
            title='DelveSiteDenizenIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class Features(BaseModel):
    pass


class Dangers(BaseModel):
    pass


class DelveSiteDomainDangerId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSiteDomainDanger object.",
            pattern="^delve_site_domain\\.danger:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$",
            title="DelveSiteDomainDangerId",
=======
DelveSiteDomainDangerId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSiteDomainDanger object.',
            pattern='^delve_site_domain\\.danger:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteDomainDangerId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteDomainDangerIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteDomainDangerId that can be used to match multiple DelveSiteDomainDanger objects.",
            pattern="^delve_site_domain\\.danger:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$",
            title="DelveSiteDomainDangerIdWildcard",
=======
DelveSiteDomainDangerIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteDomainDangerId that can be used to match multiple DelveSiteDomainDanger objects.',
            pattern='^delve_site_domain\\.danger:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$',
            title='DelveSiteDomainDangerIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteDomainFeatureId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSiteDomainFeature object.",
            pattern="^delve_site_domain\\.feature:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$",
            title="DelveSiteDomainFeatureId",
=======
DelveSiteDomainFeatureId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSiteDomainFeature object.',
            pattern='^delve_site_domain\\.feature:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteDomainFeatureId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteDomainFeatureIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteDomainFeatureId that can be used to match multiple DelveSiteDomainFeature objects.",
            pattern="^delve_site_domain\\.feature:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$",
            title="DelveSiteDomainFeatureIdWildcard",
=======
DelveSiteDomainFeatureIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteDomainFeatureId that can be used to match multiple DelveSiteDomainFeature objects.',
            pattern='^delve_site_domain\\.feature:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$',
            title='DelveSiteDomainFeatureIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteDomainId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSiteDomain object.",
            pattern="^delve_site_domain:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$",
            title="DelveSiteDomainId",
=======
DelveSiteDomainId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSiteDomain object.',
            pattern='^delve_site_domain:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteDomainId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteDomainIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteDomainId that can be used to match multiple DelveSiteDomain objects.",
            pattern="^delve_site_domain:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$",
            title="DelveSiteDomainIdWildcard",
=======
DelveSiteDomainIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteDomainId that can be used to match multiple DelveSiteDomain objects.',
            pattern='^delve_site_domain:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$',
            title='DelveSiteDomainIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSite object.",
            pattern="^delve_site:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$",
            title="DelveSiteId",
=======
DelveSiteId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSite object.',
            pattern='^delve_site:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteId that can be used to match multiple DelveSite objects.",
            pattern="^delve_site:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$",
            title="DelveSiteIdWildcard",
=======
DelveSiteIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteId that can be used to match multiple DelveSite objects.',
            pattern='^delve_site:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$',
            title='DelveSiteIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteThemeDangerId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSiteThemeDanger object.",
            pattern="^delve_site_theme\\.danger:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$",
            title="DelveSiteThemeDangerId",
=======
DelveSiteThemeDangerId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSiteThemeDanger object.',
            pattern='^delve_site_theme\\.danger:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteThemeDangerId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteThemeDangerIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteThemeDangerId that can be used to match multiple DelveSiteThemeDanger objects.",
            pattern="^delve_site_theme\\.danger:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$",
            title="DelveSiteThemeDangerIdWildcard",
=======
DelveSiteThemeDangerIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteThemeDangerId that can be used to match multiple DelveSiteThemeDanger objects.',
            pattern='^delve_site_theme\\.danger:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$',
            title='DelveSiteThemeDangerIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteThemeFeatureId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSiteThemeFeature object.",
            pattern="^delve_site_theme\\.feature:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$",
            title="DelveSiteThemeFeatureId",
=======
DelveSiteThemeFeatureId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSiteThemeFeature object.',
            pattern='^delve_site_theme\\.feature:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteThemeFeatureId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteThemeFeatureIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteThemeFeatureId that can be used to match multiple DelveSiteThemeFeature objects.",
            pattern="^delve_site_theme\\.feature:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$",
            title="DelveSiteThemeFeatureIdWildcard",
=======
DelveSiteThemeFeatureIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteThemeFeatureId that can be used to match multiple DelveSiteThemeFeature objects.',
            pattern='^delve_site_theme\\.feature:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$',
            title='DelveSiteThemeFeatureIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteThemeId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a DelveSiteTheme object.",
            pattern="^delve_site_theme:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$",
            title="DelveSiteThemeId",
=======
DelveSiteThemeId = Annotated[
        str,
        Field(
            description='A unique ID representing a DelveSiteTheme object.',
            pattern='^delve_site_theme:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteThemeId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DelveSiteThemeIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded DelveSiteThemeId that can be used to match multiple DelveSiteTheme objects.",
            pattern="^delve_site_theme:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$",
            title="DelveSiteThemeIdWildcard",
=======
DelveSiteThemeIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded DelveSiteThemeId that can be used to match multiple DelveSiteTheme objects.',
            pattern='^delve_site_theme:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$',
            title='DelveSiteThemeIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class DiceExpression(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A simple dice roll expression with an optional (positive or negative) modifer.",
            examples=["1d100", "1d6+2", "2d10"],
            pattern="([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?",
            title="DiceExpression",
=======
DiceExpression = Annotated[
        str,
        Field(
            description='A simple dice roll expression with an optional (positive or negative) modifer.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
>>>>>>> upstream/main
        ),
    ]


class DiceRange(BaseModel):
<<<<<<< HEAD
    min: Annotated[int, Field(description="Low end of the dice range.")]
    max: Annotated[int, Field(description="High end of the dice range.")]


class DictKey(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A `snake_case` key used in a Datasworn dictionary object.",
            pattern="^[a-z][a-z0-9_]*$",
            title="DictKey",
=======
    min: Annotated[int, Field(description='Low end of the dice range.')]
    max: Annotated[int, Field(description='High end of the dice range.')]


DictKey = Annotated[
        str,
        Field(
            description='A `snake_case` key used in a Datasworn dictionary object.',
            pattern='^[a-z][a-z0-9_]*$',
            title='DictKey',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class Documentation(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.",
            title="Documentation",
        ),
    ]


class Email(RootModel[EmailStr]):
    root: Annotated[EmailStr, Field(description="An email address.", title="Email")]


class RollType(Enum):
    action_roll = "action_roll"
    no_roll = "no_roll"
    progress_roll = "progress_roll"
    special_track = "special_track"
=======
class RollType(Enum):
    action_roll = 'action_roll'
    no_roll = 'no_roll'
    progress_roll = 'progress_roll'
    special_track = 'special_track'
>>>>>>> upstream/main


class EmbeddedMove(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    roll_type: RollType


<<<<<<< HEAD
class EmbeddedMoveId(RootModel[AssetAbilityMoveId]):
    root: Annotated[AssetAbilityMoveId, Field(title="EmbeddedMoveId")]


class EmbeddedMoveIdWildcard(RootModel[AssetAbilityMoveIdWildcard]):
    root: Annotated[AssetAbilityMoveIdWildcard, Field(title="EmbeddedMoveIdWildcard")]
=======
EmbeddedMoveIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded AssetAbilityMoveId that can be used to match multiple AssetAbilityMove objects.',
            pattern='^asset\\.ability\\.move:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)$',
            title='EmbeddedMoveIdWildcard',
        ),
    ]
>>>>>>> upstream/main


class RecommendedRolls(BaseModel):
    min: int
    max: int


class OracleType(Enum):
<<<<<<< HEAD
    table_text = "table_text"
    table_text2 = "table_text2"
    table_text3 = "table_text3"
    column_text = "column_text"
    column_text2 = "column_text2"
    column_text3 = "column_text3"
=======
    table_text = 'table_text'
    table_text2 = 'table_text2'
    table_text3 = 'table_text3'
    column_text = 'column_text'
    column_text2 = 'column_text2'
    column_text3 = 'column_text3'
>>>>>>> upstream/main


class EmbeddedOracleRollable(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    oracle_type: OracleType


class EmbedOnlyType(Enum):
<<<<<<< HEAD
    ability = "ability"
    option = "option"
    row = "row"
    feature = "feature"
    danger = "danger"
    denizen = "denizen"
    variant = "variant"


class ExpansionId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The ID of a Datasworn package that relies on an external package to provide its ruleset.",
            examples=["delve", "sundered_isles"],
            pattern="^[a-z][a-z0-9_]*$",
            title="ExpansionId",
=======
    ability = 'ability'
    condition = 'condition'
    outcome = 'outcome'
    option = 'option'
    row = 'row'
    feature = 'feature'
    danger = 'danger'
    denizen = 'denizen'
    variant = 'variant'


ExpansionId = Annotated[
        str,
        Field(
            description='The ID of a Datasworn package that relies on an external package to provide its ruleset.',
            examples=['delve', 'sundered_isles'],
            pattern='^[a-z][a-z0-9_]*$',
            title='ExpansionId',
>>>>>>> upstream/main
        ),
    ]


class Tags(BaseModel):
<<<<<<< HEAD
    field_core: Annotated[CoreTags | None, Field(alias="_core")] = None


class Label(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).",
            title="Label",
        ),
    ]


class MarkdownString(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title="MarkdownString",
        ),
    ]


class MarkdownTemplateString(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A rich text string in Markdown with replaced values from oracle roll results.\n\nThe custom syntax `{{some_row_key>some_oracle_table_id}}` should be replaced by the `some_row_key` string of a rolled oracle table. This is usually the `text` key, for example `{{text>oracle_rollable:starforged/core/action}}`\n",
            title="MarkdownTemplateString",
=======
    core: Annotated[CoreTags | None, Field(alias='_core')] = None


MarkdownTemplateString = Annotated[
        str,
        Field(
            description='A rich text string in Markdown with replaced values from oracle roll results.\n\nThe custom syntax `{{some_row_key>some_oracle_table_id}}` should be replaced by the `some_row_key` string of a rolled oracle table. This is usually the `text` key, for example `{{text>oracle_rollable:starforged/core/action}}`\n',
            title='MarkdownTemplateString',
>>>>>>> upstream/main
        ),
    ]


class Move(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    roll_type: RollType


<<<<<<< HEAD
class MoveCategoryId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a MoveCategory object.",
            pattern="^move_category:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$",
            title="MoveCategoryId",
=======
MoveCategoryId = Annotated[
        str,
        Field(
            description='A unique ID representing a MoveCategory object.',
            pattern='^move_category:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='MoveCategoryId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class MoveCategoryIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded MoveCategoryId that can be used to match multiple MoveCategory objects.",
            pattern="^move_category:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$",
            title="MoveCategoryIdWildcard",
=======
MoveCategoryIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded MoveCategoryId that can be used to match multiple MoveCategory objects.',
            pattern='^move_category:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$',
            title='MoveCategoryIdWildcard',
        ),
    ]


MoveConditionId = Annotated[
        str,
        Field(
            description='A unique ID representing a MoveCondition object.',
            pattern='^move\\.condition:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)$',
            title='MoveConditionId',
        ),
    ]


MoveConditionIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded MoveConditionId that can be used to match multiple MoveCondition objects.',
            pattern='^move\\.condition:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)$',
            title='MoveConditionIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class MoveEnhancement(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    roll_type: RollType


<<<<<<< HEAD
class MoveId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a Move object.",
            pattern="^move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$",
            title="MoveId",
=======
MoveId = Annotated[
        str,
        Field(
            description='A unique ID representing a Move object.',
            pattern='^move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='MoveId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class MoveIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded MoveId that can be used to match multiple Move objects.",
            pattern="^move:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$",
            title="MoveIdWildcard",
=======
MoveIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded MoveId that can be used to match multiple Move objects.',
            pattern='^move:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$',
            title='MoveIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class MoveOracleRollableId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a MoveOracleRollable object.",
            pattern="^move\\.oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)$",
            title="MoveOracleRollableId",
=======
MoveOracleRollableId = Annotated[
        str,
        Field(
            description='A unique ID representing a MoveOracleRollable object.',
            pattern='^move\\.oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)$',
            title='MoveOracleRollableId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class MoveOracleRollableIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded MoveOracleRollableId that can be used to match multiple MoveOracleRollable objects.",
            pattern="^move\\.oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.([a-z][a-z0-9_]*|\\*)$",
            title="MoveOracleRollableIdWildcard",
=======
MoveOracleRollableIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded MoveOracleRollableId that can be used to match multiple MoveOracleRollable objects.',
            pattern='^move\\.oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.([a-z][a-z0-9_]*|\\*)$',
            title='MoveOracleRollableIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class MoveOracleRollableRowId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a MoveOracleRollableRow object.",
            pattern="^move\\.oracle_rollable\\.row:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+)$",
            title="MoveOracleRollableRowId",
=======
MoveOracleRollableRowId = Annotated[
        str,
        Field(
            description='A unique ID representing a MoveOracleRollableRow object.',
            pattern='^move\\.oracle_rollable\\.row:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+)$',
            title='MoveOracleRollableRowId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class MoveOracleRollableRowIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded MoveOracleRollableRowId that can be used to match multiple MoveOracleRollableRow objects.",
            pattern="^move\\.oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+|\\*)$",
            title="MoveOracleRollableRowIdWildcard",
=======
MoveOracleRollableRowIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded MoveOracleRollableRowId that can be used to match multiple MoveOracleRollableRow objects.',
            pattern='^move\\.oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+|\\*)$',
            title='MoveOracleRollableRowIdWildcard',
        ),
    ]


MoveOutcomeId = Annotated[
        str,
        Field(
            description='A unique ID representing a MoveOutcome object.',
            pattern='^move\\.outcome:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)$',
            title='MoveOutcomeId',
        ),
    ]


MoveOutcomeIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded MoveOutcomeId that can be used to match multiple MoveOutcome objects.',
            pattern='^move\\.outcome:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.([a-z][a-z0-9_]*|\\*)$',
            title='MoveOutcomeIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class MoveRollType(Enum):
<<<<<<< HEAD
    no_roll = "no_roll"
    action_roll = "action_roll"
    progress_roll = "progress_roll"
    special_track = "special_track"


class NonCollectableType(Enum):
    delve_site = "delve_site"
    delve_site_domain = "delve_site_domain"
    delve_site_theme = "delve_site_theme"
    rarity = "rarity"
    truth = "truth"


class NpcCollectionId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a NpcCollection object.",
            pattern="^npc_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$",
            title="NpcCollectionId",
=======
    no_roll = 'no_roll'
    action_roll = 'action_roll'
    progress_roll = 'progress_roll'
    special_track = 'special_track'


class NonCollectableType(Enum):
    delve_site = 'delve_site'
    delve_site_domain = 'delve_site_domain'
    delve_site_theme = 'delve_site_theme'
    rarity = 'rarity'
    truth = 'truth'


NpcCollectionId = Annotated[
        str,
        Field(
            description='A unique ID representing a NpcCollection object.',
            pattern='^npc_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='NpcCollectionId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class NpcCollectionIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded NpcCollectionId that can be used to match multiple NpcCollection objects.",
            pattern="^npc_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$",
            title="NpcCollectionIdWildcard",
=======
NpcCollectionIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded NpcCollectionId that can be used to match multiple NpcCollection objects.',
            pattern='^npc_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$',
            title='NpcCollectionIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class NpcId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a Npc object.",
            pattern="^npc:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$",
            title="NpcId",
=======
NpcId = Annotated[
        str,
        Field(
            description='A unique ID representing a Npc object.',
            pattern='^npc:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='NpcId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class NpcIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded NpcId that can be used to match multiple Npc objects.",
            pattern="^npc:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$",
            title="NpcIdWildcard",
=======
NpcIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded NpcId that can be used to match multiple Npc objects.',
            pattern='^npc:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$',
            title='NpcIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class NpcNature(RootModel[Label]):
    root: Annotated[
        Label,
        Field(
            description="A localized category label describing the nature of this NPC.\n\nIn Ironsworn classic, this is probably the singular form of the parent collection's name.\n\nFor Starforged, see the table on p. 258 for examples.",
            examples=[
                "Ironlander",
                "Firstborn",
                "Animal",
                "Beast",
                "Horror",
                "Anomaly",
                "Creature",
                "Human",
                "Machine",
                "Monster",
                "Vehicle",
            ],
            title="NpcNature",
=======
NpcVariantId = Annotated[
        str,
        Field(
            description='A unique ID representing a NpcVariant object.',
            pattern='^npc\\.variant:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)$',
            title='NpcVariantId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class NpcVariantId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a NpcVariant object.",
            pattern="^npc\\.variant:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)$",
            title="NpcVariantId",
        ),
    ]


class NpcVariantIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded NpcVariantId that can be used to match multiple NpcVariant objects.",
            pattern="^npc\\.variant:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.([a-z][a-z0-9_]*|\\*)$",
            title="NpcVariantIdWildcard",
=======
NpcVariantIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded NpcVariantId that can be used to match multiple NpcVariant objects.',
            pattern='^npc\\.variant:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.([a-z][a-z0-9_]*|\\*)$',
            title='NpcVariantIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class OracleType1(Enum):
<<<<<<< HEAD
    tables = "tables"
    table_shared_rolls = "table_shared_rolls"
    table_shared_text = "table_shared_text"
    table_shared_text2 = "table_shared_text2"
    table_shared_text3 = "table_shared_text3"
=======
    tables = 'tables'
    table_shared_rolls = 'table_shared_rolls'
    table_shared_text = 'table_shared_text'
    table_shared_text2 = 'table_shared_text2'
    table_shared_text3 = 'table_shared_text3'
>>>>>>> upstream/main


class OracleCollection(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    oracle_type: OracleType1


<<<<<<< HEAD
class OracleCollectionId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an OracleCollection object.",
            pattern="^oracle_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$",
            title="OracleCollectionId",
=======
OracleCollectionId = Annotated[
        str,
        Field(
            description='A unique ID representing an OracleCollection object.',
            pattern='^oracle_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='OracleCollectionId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class OracleCollectionIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded OracleCollectionId that can be used to match multiple OracleCollection objects.",
            pattern="^oracle_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$",
            title="OracleCollectionIdWildcard",
=======
OracleCollectionIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded OracleCollectionId that can be used to match multiple OracleCollection objects.',
            pattern='^oracle_collection:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){1,4})$',
            title='OracleCollectionIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class OracleDuplicateBehavior(Enum):
<<<<<<< HEAD
    reroll = "reroll"
    keep = "keep"
    make_it_worse = "make_it_worse"


class OracleMatchBehavior(BaseModel):
    text: MarkdownString


class OracleType2(Enum):
    table_text = "table_text"
    table_text2 = "table_text2"
    table_text3 = "table_text3"
    column_text = "column_text"
    column_text2 = "column_text2"
    column_text3 = "column_text3"
=======
    reroll = 'reroll'
    keep = 'keep'
    make_it_worse = 'make_it_worse'


class OracleMatchBehavior(BaseModel):
    text: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]


class OracleType2(Enum):
    table_text = 'table_text'
    table_text2 = 'table_text2'
    table_text3 = 'table_text3'
    column_text = 'column_text'
    column_text2 = 'column_text2'
    column_text3 = 'column_text3'
>>>>>>> upstream/main


class OracleRollable(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    oracle_type: OracleType2


<<<<<<< HEAD
class OracleRollableId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an OracleRollable object.",
            pattern="^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$",
            title="OracleRollableId",
=======
OracleRollableId = Annotated[
        str,
        Field(
            description='A unique ID representing an OracleRollable object.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class OracleRollableIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded OracleRollableId that can be used to match multiple OracleRollable objects.",
            pattern="^oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$",
            title="OracleRollableIdWildcard",
=======
OracleRollableIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded OracleRollableId that can be used to match multiple OracleRollable objects.',
            pattern='^oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})$',
            title='OracleRollableIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class OracleRollableRowId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing an OracleRollableRow object.",
            pattern="^oracle_rollable\\.row:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)$",
            title="OracleRollableRowId",
=======
OracleRollableRowId = Annotated[
        str,
        Field(
            description='A unique ID representing an OracleRollableRow object.',
            pattern='^oracle_rollable\\.row:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)$',
            title='OracleRollableRowId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class OracleRollableRowIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded OracleRollableRowId that can be used to match multiple OracleRollableRow objects.",
            pattern="^oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)$",
            title="OracleRollableRowIdWildcard",
=======
OracleRollableRowIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded OracleRollableRowId that can be used to match multiple OracleRollableRow objects.',
            pattern='^oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)(?:\\/(?:[a-z][a-z0-9_]*|\\*|\\*\\*)){2,5})\\.(\\d+|\\*)$',
            title='OracleRollableRowIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class Template(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownTemplateString | None,
        Field(
            description="A string template that may be used in place of OracleRollableRow#text.",
            examples=[
                "{{text>oracle_rollable:starforged/faction/name/affiliation}} of the {{text>oracle_rollable:starforged/faction/name/legacy}} {{text>oracle_rollable:starforged/faction/name/identity}}"
            ],
        ),
    ] = None
    text2: Annotated[
        MarkdownTemplateString | None,
        Field(
            description="A string template that may be used in place of OracleRollableRow#text2."
        ),
    ] = None
    text3: Annotated[
        MarkdownTemplateString | None,
        Field(
            description="A string template that may be used in place of OracleRollableRow#text3."
=======
        str | None,
        Field(
            description='A string template that may be used in place of OracleRollableRow#text.',
            examples=[
                '{{text>oracle_rollable:starforged/faction/name/affiliation}} of the {{text>oracle_rollable:starforged/faction/name/legacy}} {{text>oracle_rollable:starforged/faction/name/identity}}'
            ],
            title='MarkdownTemplateString',
        ),
    ] = None
    text2: Annotated[
        str | None,
        Field(
            description='A string template that may be used in place of OracleRollableRow#text2.',
            title='MarkdownTemplateString',
        ),
    ] = None
    text3: Annotated[
        str | None,
        Field(
            description='A string template that may be used in place of OracleRollableRow#text3.',
            title='MarkdownTemplateString',
>>>>>>> upstream/main
        ),
    ] = None


class OracleType3(Enum):
<<<<<<< HEAD
    table_text = "table_text"
    table_text2 = "table_text2"
    table_text3 = "table_text3"
=======
    table_text = 'table_text'
    table_text2 = 'table_text2'
    table_text3 = 'table_text3'
>>>>>>> upstream/main


class OracleRollableTable(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    oracle_type: OracleType3


class OracleRollTemplate(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownTemplateString | None,
        Field(
            description="A string template that may be used in place of OracleRollableRow#text.",
            examples=[
                "{{text>oracle_rollable:starforged/faction/name/affiliation}} of the {{text>oracle_rollable:starforged/faction/name/legacy}} {{text>oracle_rollable:starforged/faction/name/identity}}"
            ],
        ),
    ] = None
    text2: Annotated[
        MarkdownTemplateString | None,
        Field(
            description="A string template that may be used in place of OracleRollableRow#text2."
        ),
    ] = None
    text3: Annotated[
        MarkdownTemplateString | None,
        Field(
            description="A string template that may be used in place of OracleRollableRow#text3."
=======
        str | None,
        Field(
            description='A string template that may be used in place of OracleRollableRow#text.',
            examples=[
                '{{text>oracle_rollable:starforged/faction/name/affiliation}} of the {{text>oracle_rollable:starforged/faction/name/legacy}} {{text>oracle_rollable:starforged/faction/name/identity}}'
            ],
            title='MarkdownTemplateString',
        ),
    ] = None
    text2: Annotated[
        str | None,
        Field(
            description='A string template that may be used in place of OracleRollableRow#text2.',
            title='MarkdownTemplateString',
        ),
    ] = None
    text3: Annotated[
        str | None,
        Field(
            description='A string template that may be used in place of OracleRollableRow#text3.',
            title='MarkdownTemplateString',
>>>>>>> upstream/main
        ),
    ] = None


class ColumnLabels3(BaseModel):
<<<<<<< HEAD
    roll: Label


class ColumnLabels4(BaseModel):
    text: Label


class ColumnLabels5(BaseModel):
    text: Label
    text2: Label


class ColumnLabels6(BaseModel):
    text: Label
    text2: Label
    text3: Label


class ColumnLabels7(BaseModel):
    roll: Label
    text: Label


class ColumnLabels8(BaseModel):
    roll: Label
    text: Label
    text2: Label


class ColumnLabels9(BaseModel):
    roll: Label
    text: Label
    text2: Label
    text3: Label


class PageNumber(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description="Represents a page number in a book.", ge=1, title="PageNumber"
=======
    roll: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels4(BaseModel):
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels5(BaseModel):
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text2: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels6(BaseModel):
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text2: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text3: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels7(BaseModel):
    roll: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels8(BaseModel):
    roll: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text2: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels9(BaseModel):
    roll: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text2: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text3: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
>>>>>>> upstream/main
        ),
    ]


class PartOfSpeech(Enum):
<<<<<<< HEAD
    common_noun = "common_noun"
    proper_noun = "proper_noun"
    adjunct_common_noun = "adjunct_common_noun"
    adjunct_proper_noun = "adjunct_proper_noun"
    verb = "verb"
    gerund = "gerund"
    adjective = "adjective"
    attributive_verb = "attributive_verb"
    adjective_as_proper_noun = "adjective_as_proper_noun"
    common_noun_as_proper_noun = "common_noun_as_proper_noun"


class ProgressRollMethod(Enum):
    miss = "miss"
    weak_hit = "weak_hit"
    strong_hit = "strong_hit"
    progress_roll = "progress_roll"


class ProgressRollOption(BaseModel):
    using: Literal["progress_track"]
=======
    common_noun = 'common_noun'
    proper_noun = 'proper_noun'
    adjunct_common_noun = 'adjunct_common_noun'
    adjunct_proper_noun = 'adjunct_proper_noun'
    verb = 'verb'
    gerund = 'gerund'
    adjective = 'adjective'
    attributive_verb = 'attributive_verb'
    adjective_as_proper_noun = 'adjective_as_proper_noun'
    common_noun_as_proper_noun = 'common_noun_as_proper_noun'


class ProgressRollMethod(Enum):
    miss = 'miss'
    weak_hit = 'weak_hit'
    strong_hit = 'strong_hit'
    progress_roll = 'progress_roll'


class ProgressRollOption(BaseModel):
    using: Literal['progress_track']
>>>>>>> upstream/main


class ProgressTrackTypeInfo(BaseModel):
    category: Annotated[
<<<<<<< HEAD
        Label,
        Field(
            description="A category label for progress tracks of this type.",
            examples=[
                "Vow",
                "Journey",
                "Combat",
                "Scene Challenge",
                "Expedition",
                "Connection",
                "Delve",
            ],
=======
        str,
        Field(
            description='A category label for progress tracks of this type.',
            examples=[
                'Vow',
                'Journey',
                'Combat',
                'Scene Challenge',
                'Expedition',
                'Connection',
                'Delve',
            ],
            title='Label',
>>>>>>> upstream/main
        ),
    ]
    controls: dict[str, dict[str, Any]] | None = {}


<<<<<<< HEAD
class RarityId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a Rarity object.",
            pattern="^rarity:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$",
            title="RarityId",
=======
RarityId = Annotated[
        str,
        Field(
            description='A unique ID representing a Rarity object.',
            pattern='^rarity:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='RarityId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class RarityIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded RarityId that can be used to match multiple Rarity objects.",
            pattern="^rarity:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$",
            title="RarityIdWildcard",
=======
RarityIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded RarityId that can be used to match multiple Rarity objects.',
            pattern='^rarity:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$',
            title='RarityIdWildcard',
>>>>>>> upstream/main
        ),
    ]


class Using(Enum):
<<<<<<< HEAD
    stat = "stat"
    condition_meter = "condition_meter"
    asset_control = "asset_control"
    asset_option = "asset_option"
    attached_asset_control = "attached_asset_control"
    attached_asset_option = "attached_asset_option"
    custom = "custom"
=======
    stat = 'stat'
    condition_meter = 'condition_meter'
    asset_control = 'asset_control'
    asset_option = 'asset_option'
    attached_asset_control = 'attached_asset_control'
    attached_asset_option = 'attached_asset_option'
    custom = 'custom'
>>>>>>> upstream/main


class RollableValue(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    using: Using


<<<<<<< HEAD
class RulesetId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The ID of standalone Datasworn package that describes its own ruleset.",
            examples=["classic", "starforged"],
            pattern="^[a-z][a-z0-9_]*$",
            title="RulesetId",
=======
RulesetId = Annotated[
        str,
        Field(
            description='The ID of standalone Datasworn package that describes its own ruleset.',
            examples=['classic', 'starforged'],
            pattern='^[a-z][a-z0-9_]*$',
            title='RulesetId',
>>>>>>> upstream/main
        ),
    ]


class Type(Enum):
<<<<<<< HEAD
    ruleset = "ruleset"
    expansion = "expansion"
=======
    ruleset = 'ruleset'
    expansion = 'expansion'
>>>>>>> upstream/main


class RulesPackage(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    type: Type


<<<<<<< HEAD
class RulesPackageId(RootModel[RulesetId | ExpansionId]):
    root: Annotated[RulesetId | ExpansionId, Field(title="RulesPackageId")]


class RuleType(Enum):
    impact = "impact"
    condition_meter = "condition_meter"
    special_track = "special_track"
    stat = "stat"


class ChoiceType(Enum):
    choice = "choice"
    choice_group = "choice_group"
=======
RulesPackageId = Annotated[RulesetId | ExpansionId, Field(title='RulesPackageId')]


class RuleType(Enum):
    impact = 'impact'
    condition_meter = 'condition_meter'
    special_track = 'special_track'
    stat = 'stat'


class ChoiceType(Enum):
    choice = 'choice'
    choice_group = 'choice_group'
>>>>>>> upstream/main


class Choices(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    choice_type: ChoiceType


class SelectValueFieldChoice(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    using: Using


<<<<<<< HEAD
class SemanticVersion(RootModel[str]):
    root: Annotated[
        str,
        Field(
            pattern="^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$",
            title="SemanticVersion",
=======
SemanticVersion = Annotated[
        str,
        Field(
            pattern='^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$',
            title='SemanticVersion',
>>>>>>> upstream/main
        ),
    ]


class SpecialTrackRollMethod(Enum):
<<<<<<< HEAD
    miss = "miss"
    weak_hit = "weak_hit"
    strong_hit = "strong_hit"
    player_choice = "player_choice"
    highest = "highest"
    lowest = "lowest"
    all = "all"


class SpecialTrackRule(BaseModel):
    label: Annotated[Label, Field(description="A label for this special track.")]
    description: Annotated[
        MarkdownString, Field(description="A description of this special track.")
    ]
    shared: Annotated[bool, Field(description="Is this track shared by all players?")]
    optional: Annotated[bool, Field(description="Is this track an optional rule?")]
    tags: Tags | None = None


class SpecialTrackType(RootModel[DictKey]):
    root: Annotated[
        DictKey,
        Field(
            description="Special, ruleset-specific progress tracks. Usually, one exists per player character, and they persist through the life of the player character.\n'Canonical' examples:\n  * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged legacy track, use `bonds_legacy` instead.\n  * `failure_track`, described in Ironsworn: Delve\n  * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described Ironsworn: Starforged\n\n",
            examples=[
                "bonds_track",
                "failure_track",
                "quests_legacy",
                "bonds_legacy",
                "discoveries_legacy",
            ],
            title="SpecialTrackType",
        ),
    ]


class StatKey(RootModel[DictKey]):
    root: Annotated[
        DictKey,
        Field(
            description="A basic player character stat.",
            examples=["edge", "heart", "iron", "shadow", "wits"],
            title="StatKey",
        ),
    ]


class StatRule(BaseModel):
    label: Annotated[
        Label, Field(description="A label for this stat.", examples=["edge"])
    ]
    description: Annotated[
        MarkdownString,
        Field(
            description="A description of this stat.",
            examples=["Quickness, agility, and prowess when fighting at a distance."],
=======
    miss = 'miss'
    weak_hit = 'weak_hit'
    strong_hit = 'strong_hit'
    player_choice = 'player_choice'
    highest = 'highest'
    lowest = 'lowest'
    all = 'all'


class SpecialTrackRule(BaseModel):
    label: Annotated[
        str, Field(description='A label for this special track.', title='Label')
    ]
    description: Annotated[
        str,
        Field(
            description='A description of this special track.', title='MarkdownString'
        ),
    ]
    shared: Annotated[bool, Field(description='Is this track shared by all players?')]
    optional: Annotated[bool, Field(description='Is this track an optional rule?')]
    tags: Tags | None = None


class StatRule(BaseModel):
    label: Annotated[
        str,
        Field(description='A label for this stat.', examples=['edge'], title='Label'),
    ]
    description: Annotated[
        str,
        Field(
            description='A description of this stat.',
            examples=['Quickness, agility, and prowess when fighting at a distance.'],
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ]
    tags: Tags | None = None


class StatValueRef(BaseModel):
<<<<<<< HEAD
    stat: StatKey
    using: Annotated[
        Literal["stat"],
        Field(
            description="A reference to the value of a standard player character stat."
        ),
    ]


class SvgImageUrl(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A relative (local) URL pointing to a vector image in the SVG format.",
            pattern="\\.svg$",
            title="SvgImageUrl",
=======
    stat: Annotated[
        str,
        Field(
            description='A basic player character stat.',
            examples=['edge', 'heart', 'iron', 'shadow', 'wits'],
            pattern='^[a-z][a-z0-9_]*$',
            title='StatKey',
        ),
    ]
    using: Annotated[
        Literal['stat'],
        Field(
            description='A reference to the value of a standard player character stat.'
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TaggableNodeType(
    RootModel[
        CollectableType | NonCollectableType | CollectionType | EmbedOnlyType | RuleType
    ]
):
    root: Annotated[
        CollectableType
        | NonCollectableType
        | CollectionType
        | EmbedOnlyType
        | RuleType,
        Field(title="TaggableNodeType"),
    ]


class FieldRef(Enum):
    field_definitions_ActionRollMethod = "#/definitions/ActionRollMethod"
    field_definitions_AnyId = "#/definitions/AnyId"
    field_definitions_AnyIdWildcard = "#/definitions/AnyIdWildcard"
    field_definitions_AnyMoveId = "#/definitions/AnyMoveId"
    field_definitions_AnyMoveIdWildcard = "#/definitions/AnyMoveIdWildcard"
    field_definitions_AnyOracleRollableId = "#/definitions/AnyOracleRollableId"
    field_definitions_AnyOracleRollableIdWildcard = (
        "#/definitions/AnyOracleRollableIdWildcard"
    )
    field_definitions_AnyOracleRollableRowId = "#/definitions/AnyOracleRollableRowId"
    field_definitions_AnyOracleRollableRowIdWildcard = (
        "#/definitions/AnyOracleRollableRowIdWildcard"
    )
    field_definitions_AssetAbilityId = "#/definitions/AssetAbilityId"
    field_definitions_AssetAbilityIdWildcard = "#/definitions/AssetAbilityIdWildcard"
    field_definitions_AssetAbilityMoveId = "#/definitions/AssetAbilityMoveId"
    field_definitions_AssetAbilityMoveIdWildcard = (
        "#/definitions/AssetAbilityMoveIdWildcard"
    )
    field_definitions_AssetAbilityOracleRollableId = (
        "#/definitions/AssetAbilityOracleRollableId"
    )
    field_definitions_AssetAbilityOracleRollableIdWildcard = (
        "#/definitions/AssetAbilityOracleRollableIdWildcard"
    )
    field_definitions_AssetAbilityOracleRollableRowId = (
        "#/definitions/AssetAbilityOracleRollableRowId"
    )
    field_definitions_AssetAbilityOracleRollableRowIdWildcard = (
        "#/definitions/AssetAbilityOracleRollableRowIdWildcard"
    )
    field_definitions_AssetCollectionId = "#/definitions/AssetCollectionId"
    field_definitions_AssetCollectionIdWildcard = (
        "#/definitions/AssetCollectionIdWildcard"
    )
    field_definitions_AssetId = "#/definitions/AssetId"
    field_definitions_AssetIdWildcard = "#/definitions/AssetIdWildcard"
    field_definitions_AtlasCollectionId = "#/definitions/AtlasCollectionId"
    field_definitions_AtlasCollectionIdWildcard = (
        "#/definitions/AtlasCollectionIdWildcard"
    )
    field_definitions_AtlasEntryId = "#/definitions/AtlasEntryId"
    field_definitions_AtlasEntryIdWildcard = "#/definitions/AtlasEntryIdWildcard"
    field_definitions_ChallengeRank = "#/definitions/ChallengeRank"
    field_definitions_CollectableType = "#/definitions/CollectableType"
    field_definitions_CollectionType = "#/definitions/CollectionType"
    field_definitions_CssColor = "#/definitions/CssColor"
    field_definitions_DelveSiteDenizenFrequency = (
        "#/definitions/DelveSiteDenizenFrequency"
    )
    field_definitions_DelveSiteDenizenId = "#/definitions/DelveSiteDenizenId"
    field_definitions_DelveSiteDenizenIdWildcard = (
        "#/definitions/DelveSiteDenizenIdWildcard"
    )
    field_definitions_DelveSiteDomainDangerId = "#/definitions/DelveSiteDomainDangerId"
    field_definitions_DelveSiteDomainDangerIdWildcard = (
        "#/definitions/DelveSiteDomainDangerIdWildcard"
    )
    field_definitions_DelveSiteDomainFeatureId = (
        "#/definitions/DelveSiteDomainFeatureId"
    )
    field_definitions_DelveSiteDomainFeatureIdWildcard = (
        "#/definitions/DelveSiteDomainFeatureIdWildcard"
    )
    field_definitions_DelveSiteDomainId = "#/definitions/DelveSiteDomainId"
    field_definitions_DelveSiteDomainIdWildcard = (
        "#/definitions/DelveSiteDomainIdWildcard"
    )
    field_definitions_DelveSiteId = "#/definitions/DelveSiteId"
    field_definitions_DelveSiteIdWildcard = "#/definitions/DelveSiteIdWildcard"
    field_definitions_DelveSiteThemeDangerId = "#/definitions/DelveSiteThemeDangerId"
    field_definitions_DelveSiteThemeDangerIdWildcard = (
        "#/definitions/DelveSiteThemeDangerIdWildcard"
    )
    field_definitions_DelveSiteThemeFeatureId = "#/definitions/DelveSiteThemeFeatureId"
    field_definitions_DelveSiteThemeFeatureIdWildcard = (
        "#/definitions/DelveSiteThemeFeatureIdWildcard"
    )
    field_definitions_DelveSiteThemeId = "#/definitions/DelveSiteThemeId"
    field_definitions_DelveSiteThemeIdWildcard = (
        "#/definitions/DelveSiteThemeIdWildcard"
    )
    field_definitions_DiceExpression = "#/definitions/DiceExpression"
    field_definitions_DictKey = "#/definitions/DictKey"
    field_definitions_Documentation = "#/definitions/Documentation"
    field_definitions_Email = "#/definitions/Email"
    field_definitions_EmbeddedMoveId = "#/definitions/EmbeddedMoveId"
    field_definitions_EmbeddedMoveIdWildcard = "#/definitions/EmbeddedMoveIdWildcard"
    field_definitions_EmbeddedOracleRollableId = (
        "#/definitions/EmbeddedOracleRollableId"
    )
    field_definitions_EmbeddedOracleRollableIdWildcard = (
        "#/definitions/EmbeddedOracleRollableIdWildcard"
    )
    field_definitions_EmbedOnlyType = "#/definitions/EmbedOnlyType"
    field_definitions_ExpansionId = "#/definitions/ExpansionId"
    field_definitions_Label = "#/definitions/Label"
    field_definitions_MarkdownString = "#/definitions/MarkdownString"
    field_definitions_MarkdownTemplateString = "#/definitions/MarkdownTemplateString"
    field_definitions_MoveCategoryId = "#/definitions/MoveCategoryId"
    field_definitions_MoveCategoryIdWildcard = "#/definitions/MoveCategoryIdWildcard"
    field_definitions_MoveId = "#/definitions/MoveId"
    field_definitions_MoveIdWildcard = "#/definitions/MoveIdWildcard"
    field_definitions_MoveOracleRollableId = "#/definitions/MoveOracleRollableId"
    field_definitions_MoveOracleRollableIdWildcard = (
        "#/definitions/MoveOracleRollableIdWildcard"
    )
    field_definitions_MoveOracleRollableRowId = "#/definitions/MoveOracleRollableRowId"
    field_definitions_MoveOracleRollableRowIdWildcard = (
        "#/definitions/MoveOracleRollableRowIdWildcard"
    )
    field_definitions_MoveRollType = "#/definitions/MoveRollType"
    field_definitions_NonCollectableType = "#/definitions/NonCollectableType"
    field_definitions_NpcCollectionId = "#/definitions/NpcCollectionId"
    field_definitions_NpcCollectionIdWildcard = "#/definitions/NpcCollectionIdWildcard"
    field_definitions_NpcId = "#/definitions/NpcId"
    field_definitions_NpcIdWildcard = "#/definitions/NpcIdWildcard"
    field_definitions_NpcVariantId = "#/definitions/NpcVariantId"
    field_definitions_NpcVariantIdWildcard = "#/definitions/NpcVariantIdWildcard"
    field_definitions_OracleCollectionId = "#/definitions/OracleCollectionId"
    field_definitions_OracleCollectionIdWildcard = (
        "#/definitions/OracleCollectionIdWildcard"
    )
    field_definitions_OracleDuplicateBehavior = "#/definitions/OracleDuplicateBehavior"
    field_definitions_OracleRollableId = "#/definitions/OracleRollableId"
    field_definitions_OracleRollableIdWildcard = (
        "#/definitions/OracleRollableIdWildcard"
    )
    field_definitions_OracleRollableRowId = "#/definitions/OracleRollableRowId"
    field_definitions_OracleRollableRowIdWildcard = (
        "#/definitions/OracleRollableRowIdWildcard"
    )
    field_definitions_PageNumber = "#/definitions/PageNumber"
    field_definitions_PartOfSpeech = "#/definitions/PartOfSpeech"
    field_definitions_ProgressRollMethod = "#/definitions/ProgressRollMethod"
    field_definitions_RarityId = "#/definitions/RarityId"
    field_definitions_RarityIdWildcard = "#/definitions/RarityIdWildcard"
    field_definitions_RulesetId = "#/definitions/RulesetId"
    field_definitions_RulesPackageId = "#/definitions/RulesPackageId"
    field_definitions_RuleType = "#/definitions/RuleType"
    field_definitions_SemanticVersion = "#/definitions/SemanticVersion"
    field_definitions_SpecialTrackRollMethod = "#/definitions/SpecialTrackRollMethod"
    field_definitions_SvgImageUrl = "#/definitions/SvgImageUrl"
    field_definitions_TruthId = "#/definitions/TruthId"
    field_definitions_TruthIdWildcard = "#/definitions/TruthIdWildcard"
    field_definitions_TruthOptionId = "#/definitions/TruthOptionId"
    field_definitions_TruthOptionIdWildcard = "#/definitions/TruthOptionIdWildcard"
    field_definitions_TruthOptionOracleRollableId = (
        "#/definitions/TruthOptionOracleRollableId"
    )
    field_definitions_TruthOptionOracleRollableIdWildcard = (
        "#/definitions/TruthOptionOracleRollableIdWildcard"
    )
    field_definitions_TruthOptionOracleRollableRowId = (
        "#/definitions/TruthOptionOracleRollableRowId"
    )
    field_definitions_TruthOptionOracleRollableRowIdWildcard = (
        "#/definitions/TruthOptionOracleRollableRowIdWildcard"
    )
    field_definitions_WebpImageUrl = "#/definitions/WebpImageUrl"
    field_definitions_WebUrl = "#/definitions/WebUrl"
=======
class Ref(Enum):
    definitions_ActionRollMethod = '#/definitions/ActionRollMethod'
    definitions_AnyId = '#/definitions/AnyId'
    definitions_AnyIdWildcard = '#/definitions/AnyIdWildcard'
    definitions_AnyMoveConditionId = '#/definitions/AnyMoveConditionId'
    definitions_AnyMoveConditionIdWildcard = '#/definitions/AnyMoveConditionIdWildcard'
    definitions_AnyMoveId = '#/definitions/AnyMoveId'
    definitions_AnyMoveIdWildcard = '#/definitions/AnyMoveIdWildcard'
    definitions_AnyMoveOutcomeId = '#/definitions/AnyMoveOutcomeId'
    definitions_AnyMoveOutcomeIdWildcard = '#/definitions/AnyMoveOutcomeIdWildcard'
    definitions_AnyOracleRollableId = '#/definitions/AnyOracleRollableId'
    definitions_AnyOracleRollableIdWildcard = (
        '#/definitions/AnyOracleRollableIdWildcard'
    )
    definitions_AnyOracleRollableRowId = '#/definitions/AnyOracleRollableRowId'
    definitions_AnyOracleRollableRowIdWildcard = (
        '#/definitions/AnyOracleRollableRowIdWildcard'
    )
    definitions_AssetAbilityId = '#/definitions/AssetAbilityId'
    definitions_AssetAbilityIdWildcard = '#/definitions/AssetAbilityIdWildcard'
    definitions_AssetAbilityMoveConditionId = (
        '#/definitions/AssetAbilityMoveConditionId'
    )
    definitions_AssetAbilityMoveConditionIdWildcard = (
        '#/definitions/AssetAbilityMoveConditionIdWildcard'
    )
    definitions_AssetAbilityMoveId = '#/definitions/AssetAbilityMoveId'
    definitions_AssetAbilityMoveIdWildcard = '#/definitions/AssetAbilityMoveIdWildcard'
    definitions_AssetAbilityMoveOutcomeId = '#/definitions/AssetAbilityMoveOutcomeId'
    definitions_AssetAbilityMoveOutcomeIdWildcard = (
        '#/definitions/AssetAbilityMoveOutcomeIdWildcard'
    )
    definitions_AssetAbilityOracleRollableId = (
        '#/definitions/AssetAbilityOracleRollableId'
    )
    definitions_AssetAbilityOracleRollableIdWildcard = (
        '#/definitions/AssetAbilityOracleRollableIdWildcard'
    )
    definitions_AssetAbilityOracleRollableRowId = (
        '#/definitions/AssetAbilityOracleRollableRowId'
    )
    definitions_AssetAbilityOracleRollableRowIdWildcard = (
        '#/definitions/AssetAbilityOracleRollableRowIdWildcard'
    )
    definitions_AssetCollectionId = '#/definitions/AssetCollectionId'
    definitions_AssetCollectionIdWildcard = '#/definitions/AssetCollectionIdWildcard'
    definitions_AssetId = '#/definitions/AssetId'
    definitions_AssetIdWildcard = '#/definitions/AssetIdWildcard'
    definitions_AtlasCollectionId = '#/definitions/AtlasCollectionId'
    definitions_AtlasCollectionIdWildcard = '#/definitions/AtlasCollectionIdWildcard'
    definitions_AtlasEntryId = '#/definitions/AtlasEntryId'
    definitions_AtlasEntryIdWildcard = '#/definitions/AtlasEntryIdWildcard'
    definitions_ChallengeRank = '#/definitions/ChallengeRank'
    definitions_CollectableType = '#/definitions/CollectableType'
    definitions_CollectionType = '#/definitions/CollectionType'
    definitions_CssColor = '#/definitions/CssColor'
    definitions_DelveSiteDenizenFrequency = '#/definitions/DelveSiteDenizenFrequency'
    definitions_DelveSiteDenizenId = '#/definitions/DelveSiteDenizenId'
    definitions_DelveSiteDenizenIdWildcard = '#/definitions/DelveSiteDenizenIdWildcard'
    definitions_DelveSiteDomainDangerId = '#/definitions/DelveSiteDomainDangerId'
    definitions_DelveSiteDomainDangerIdWildcard = (
        '#/definitions/DelveSiteDomainDangerIdWildcard'
    )
    definitions_DelveSiteDomainFeatureId = '#/definitions/DelveSiteDomainFeatureId'
    definitions_DelveSiteDomainFeatureIdWildcard = (
        '#/definitions/DelveSiteDomainFeatureIdWildcard'
    )
    definitions_DelveSiteDomainId = '#/definitions/DelveSiteDomainId'
    definitions_DelveSiteDomainIdWildcard = '#/definitions/DelveSiteDomainIdWildcard'
    definitions_DelveSiteId = '#/definitions/DelveSiteId'
    definitions_DelveSiteIdWildcard = '#/definitions/DelveSiteIdWildcard'
    definitions_DelveSiteThemeDangerId = '#/definitions/DelveSiteThemeDangerId'
    definitions_DelveSiteThemeDangerIdWildcard = (
        '#/definitions/DelveSiteThemeDangerIdWildcard'
    )
    definitions_DelveSiteThemeFeatureId = '#/definitions/DelveSiteThemeFeatureId'
    definitions_DelveSiteThemeFeatureIdWildcard = (
        '#/definitions/DelveSiteThemeFeatureIdWildcard'
    )
    definitions_DelveSiteThemeId = '#/definitions/DelveSiteThemeId'
    definitions_DelveSiteThemeIdWildcard = '#/definitions/DelveSiteThemeIdWildcard'
    definitions_DiceExpression = '#/definitions/DiceExpression'
    definitions_DictKey = '#/definitions/DictKey'
    definitions_Documentation = '#/definitions/Documentation'
    definitions_Email = '#/definitions/Email'
    definitions_EmbeddedMoveId = '#/definitions/EmbeddedMoveId'
    definitions_EmbeddedMoveIdWildcard = '#/definitions/EmbeddedMoveIdWildcard'
    definitions_EmbeddedOracleRollableId = '#/definitions/EmbeddedOracleRollableId'
    definitions_EmbeddedOracleRollableIdWildcard = (
        '#/definitions/EmbeddedOracleRollableIdWildcard'
    )
    definitions_EmbedOnlyType = '#/definitions/EmbedOnlyType'
    definitions_ExpansionId = '#/definitions/ExpansionId'
    definitions_Label = '#/definitions/Label'
    definitions_MarkdownString = '#/definitions/MarkdownString'
    definitions_MarkdownTemplateString = '#/definitions/MarkdownTemplateString'
    definitions_MoveCategoryId = '#/definitions/MoveCategoryId'
    definitions_MoveCategoryIdWildcard = '#/definitions/MoveCategoryIdWildcard'
    definitions_MoveConditionId = '#/definitions/MoveConditionId'
    definitions_MoveConditionIdWildcard = '#/definitions/MoveConditionIdWildcard'
    definitions_MoveId = '#/definitions/MoveId'
    definitions_MoveIdWildcard = '#/definitions/MoveIdWildcard'
    definitions_MoveOracleRollableId = '#/definitions/MoveOracleRollableId'
    definitions_MoveOracleRollableIdWildcard = (
        '#/definitions/MoveOracleRollableIdWildcard'
    )
    definitions_MoveOracleRollableRowId = '#/definitions/MoveOracleRollableRowId'
    definitions_MoveOracleRollableRowIdWildcard = (
        '#/definitions/MoveOracleRollableRowIdWildcard'
    )
    definitions_MoveOutcomeId = '#/definitions/MoveOutcomeId'
    definitions_MoveOutcomeIdWildcard = '#/definitions/MoveOutcomeIdWildcard'
    definitions_MoveRollType = '#/definitions/MoveRollType'
    definitions_NonCollectableType = '#/definitions/NonCollectableType'
    definitions_NpcCollectionId = '#/definitions/NpcCollectionId'
    definitions_NpcCollectionIdWildcard = '#/definitions/NpcCollectionIdWildcard'
    definitions_NpcId = '#/definitions/NpcId'
    definitions_NpcIdWildcard = '#/definitions/NpcIdWildcard'
    definitions_NpcVariantId = '#/definitions/NpcVariantId'
    definitions_NpcVariantIdWildcard = '#/definitions/NpcVariantIdWildcard'
    definitions_OracleCollectionId = '#/definitions/OracleCollectionId'
    definitions_OracleCollectionIdWildcard = '#/definitions/OracleCollectionIdWildcard'
    definitions_OracleDuplicateBehavior = '#/definitions/OracleDuplicateBehavior'
    definitions_OracleRollableId = '#/definitions/OracleRollableId'
    definitions_OracleRollableIdWildcard = '#/definitions/OracleRollableIdWildcard'
    definitions_OracleRollableRowId = '#/definitions/OracleRollableRowId'
    definitions_OracleRollableRowIdWildcard = (
        '#/definitions/OracleRollableRowIdWildcard'
    )
    definitions_PageNumber = '#/definitions/PageNumber'
    definitions_PartOfSpeech = '#/definitions/PartOfSpeech'
    definitions_ProgressRollMethod = '#/definitions/ProgressRollMethod'
    definitions_RarityId = '#/definitions/RarityId'
    definitions_RarityIdWildcard = '#/definitions/RarityIdWildcard'
    definitions_RulesetId = '#/definitions/RulesetId'
    definitions_RulesPackageId = '#/definitions/RulesPackageId'
    definitions_RuleType = '#/definitions/RuleType'
    definitions_SemanticVersion = '#/definitions/SemanticVersion'
    definitions_SpecialTrackRollMethod = '#/definitions/SpecialTrackRollMethod'
    definitions_SvgImageUrl = '#/definitions/SvgImageUrl'
    definitions_TruthId = '#/definitions/TruthId'
    definitions_TruthIdWildcard = '#/definitions/TruthIdWildcard'
    definitions_TruthOptionId = '#/definitions/TruthOptionId'
    definitions_TruthOptionIdWildcard = '#/definitions/TruthOptionIdWildcard'
    definitions_TruthOptionOracleRollableId = (
        '#/definitions/TruthOptionOracleRollableId'
    )
    definitions_TruthOptionOracleRollableIdWildcard = (
        '#/definitions/TruthOptionOracleRollableIdWildcard'
    )
    definitions_TruthOptionOracleRollableRowId = (
        '#/definitions/TruthOptionOracleRollableRowId'
    )
    definitions_TruthOptionOracleRollableRowIdWildcard = (
        '#/definitions/TruthOptionOracleRollableRowIdWildcard'
    )
    definitions_WebpImageUrl = '#/definitions/WebpImageUrl'
    definitions_WebUrl = '#/definitions/WebUrl'
>>>>>>> upstream/main


class TagSchema1(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    field_ref: Annotated[FieldRef, Field(alias="$ref")]
=======
        extra='allow',
    )
    ref: Annotated[Ref, Field(alias='$ref')]
>>>>>>> upstream/main


class TagSchema2(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    enum: list[DictKey]


class TagSchema3(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
=======
        extra='allow',
>>>>>>> upstream/main
    )
    enum: list[int]


class TagSchema4(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    type: Literal["boolean"]
=======
        extra='allow',
    )
    type: Literal['boolean']
>>>>>>> upstream/main


class TagSchema5(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    type: Literal["integer"]
=======
        extra='allow',
    )
    type: Literal['integer']
>>>>>>> upstream/main


class TagSchema6(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    type: Literal["number"]


class NonNegativeInteger(RootModel[int]):
    root: Annotated[int, Field(ge=0)]
=======
        extra='allow',
    )
    type: Literal['number']
>>>>>>> upstream/main


class NonNegativeIntegerDefault0(BaseModel):
    pass


class SimpleTypes(Enum):
<<<<<<< HEAD
    array = "array"
    boolean = "boolean"
    integer = "integer"
    null = "null"
    number = "number"
    object = "object"
    string = "string"


class StringArray(RootModel[list[str]]):
    root: list[str]


class TextField(BaseModel):
    label: Label
=======
    array = 'array'
    boolean = 'boolean'
    integer = 'integer'
    null = 'null'
    number = 'number'
    object = 'object'
    string = 'string'


class StringArray(RootModel[list[str]]):
    root: list[str] = []


class TextField(BaseModel):
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
>>>>>>> upstream/main
    value: Annotated[
        str | None,
        Field(description="The content of this text input, or `null` if it's empty"),
    ]
<<<<<<< HEAD
    field_type: Literal["text"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
    field_type: Literal['text']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None


class TriggerBy(BaseModel):
    player: Annotated[
        bool,
<<<<<<< HEAD
        Field(description="Can this trigger be activated by the player who owns this?"),
=======
        Field(description='Can this trigger be activated by the player who owns this?'),
>>>>>>> upstream/main
    ]
    ally: Annotated[
        bool,
        Field(
            description="Can this trigger be activated by one of the player's allies?"
        ),
    ]


<<<<<<< HEAD
class TriggerNoRollCondition(BaseModel):
    text: Annotated[
        MarkdownString | None,
        Field(
            description="A markdown string of any trigger text specific to this trigger condition."
=======
class TriggerNoRollConditionEnhancement(BaseModel):
    text: Annotated[
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    by: TriggerBy | None = None
    method: None
    roll_options: Annotated[
        None,
        Field(
<<<<<<< HEAD
            description="The options available when rolling with this trigger condition."
=======
            description='The options available when rolling with this trigger condition.'
>>>>>>> upstream/main
        ),
    ]


class TriggerNoRollEnhancement(BaseModel):
    conditions: Annotated[
<<<<<<< HEAD
        list[TriggerNoRollCondition],
        Field(description="Trigger conditions added to the enhanced move."),
    ]


class TriggerProgressRollCondition(BaseModel):
    text: Annotated[
        MarkdownString | None,
        Field(
            description="A markdown string of any trigger text specific to this trigger condition."
        ),
    ] = None
    by: TriggerBy | None = None
    method: ProgressRollMethod
    roll_options: Annotated[
        list[ProgressRollOption],
        Field(
            description="The options available when rolling with this trigger condition."
        ),
=======
        list[TriggerNoRollConditionEnhancement],
        Field(description='Trigger conditions added to the enhanced move.'),
>>>>>>> upstream/main
    ]


class TriggerProgressRollConditionEnhancement(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description="A markdown string of any trigger text specific to this trigger condition."
=======
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    by: TriggerBy | None = None
    method: Annotated[
        ProgressRollMethod | None,
        Field(
<<<<<<< HEAD
            description="A `null` value means this condition provides no roll mechanic of its own; it must be used with another trigger condition that provides a non-null `method`."
=======
            description='A `null` value means this condition provides no roll mechanic of its own; it must be used with another trigger condition that provides a non-null `method`.'
>>>>>>> upstream/main
        ),
    ]
    roll_options: list[ProgressRollOption] | None


class TriggerProgressRollEnhancement(BaseModel):
    conditions: Annotated[
        list[TriggerProgressRollConditionEnhancement],
<<<<<<< HEAD
        Field(description="Trigger conditions added to the enhanced move."),
=======
        Field(description='Trigger conditions added to the enhanced move.'),
>>>>>>> upstream/main
    ]


class TriggerSpecialTrackConditionOption(BaseModel):
<<<<<<< HEAD
    using: SpecialTrackType


class TruthId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a Truth object.",
            pattern="^truth:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$",
            title="TruthId",
=======
    using: Annotated[
        str,
        Field(
            description="Special, ruleset-specific progress tracks. Usually, one exists per player character, and they persist through the life of the player character.\n'Canonical' examples:\n  * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged legacy track, use `bonds_legacy` instead.\n  * `failure_track`, described in Ironsworn: Delve\n  * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described Ironsworn: Starforged\n\n",
            examples=[
                'bonds_track',
                'failure_track',
                'quests_legacy',
                'bonds_legacy',
                'discoveries_legacy',
            ],
            pattern='^[a-z][a-z0-9_]*$',
            title='SpecialTrackType',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TruthIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded TruthId that can be used to match multiple Truth objects.",
            pattern="^truth:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$",
            title="TruthIdWildcard",
=======
TruthId = Annotated[
        str,
        Field(
            description='A unique ID representing a Truth object.',
            pattern='^truth:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='TruthId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TruthOptionId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a TruthOption object.",
            pattern="^truth\\.option:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$",
            title="TruthOptionId",
=======
TruthIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded TruthId that can be used to match multiple Truth objects.',
            pattern='^truth:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)$',
            title='TruthIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TruthOptionIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded TruthOptionId that can be used to match multiple TruthOption objects.",
            pattern="^truth\\.option:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$",
            title="TruthOptionIdWildcard",
=======
TruthOptionId = Annotated[
        str,
        Field(
            description='A unique ID representing a TruthOption object.',
            pattern='^truth\\.option:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='TruthOptionId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TruthOptionOracleRollableId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a TruthOptionOracleRollable object.",
            pattern="^truth\\.option\\.oracle_rollable:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$",
            title="TruthOptionOracleRollableId",
=======
TruthOptionIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded TruthOptionId that can be used to match multiple TruthOption objects.',
            pattern='^truth\\.option:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)$',
            title='TruthOptionIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TruthOptionOracleRollableIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded TruthOptionOracleRollableId that can be used to match multiple TruthOptionOracleRollable objects.",
            pattern="^truth\\.option\\.oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)$",
            title="TruthOptionOracleRollableIdWildcard",
=======
TruthOptionOracleRollableId = Annotated[
        str,
        Field(
            description='A unique ID representing a TruthOptionOracleRollable object.',
            pattern='^truth\\.option\\.oracle_rollable:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$',
            title='TruthOptionOracleRollableId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TruthOptionOracleRollableRowId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique ID representing a TruthOptionOracleRollableRow object.",
            pattern="^truth\\.option\\.oracle_rollable\\.row:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+)$",
            title="TruthOptionOracleRollableRowId",
=======
TruthOptionOracleRollableIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded TruthOptionOracleRollableId that can be used to match multiple TruthOptionOracleRollable objects.',
            pattern='^truth\\.option\\.oracle_rollable:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)$',
            title='TruthOptionOracleRollableIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class TruthOptionOracleRollableRowIdWildcard(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A wildcarded TruthOptionOracleRollableRowId that can be used to match multiple TruthOptionOracleRollableRow objects.",
            pattern="^truth\\.option\\.oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+|\\*)$",
            title="TruthOptionOracleRollableRowIdWildcard",
=======
TruthOptionOracleRollableRowId = Annotated[
        str,
        Field(
            description='A unique ID representing a TruthOptionOracleRollableRow object.',
            pattern='^truth\\.option\\.oracle_rollable\\.row:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+)$',
            title='TruthOptionOracleRollableRowId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class WebpImageUrl(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A relative (local) URL pointing to a raster image in the WEBP format.",
            pattern="\\.webp$",
            title="WebpImageUrl",
=======
TruthOptionOracleRollableRowIdWildcard = Annotated[
        str,
        Field(
            description='A wildcarded TruthOptionOracleRollableRowId that can be used to match multiple TruthOptionOracleRollableRow objects.',
            pattern='^truth\\.option\\.oracle_rollable\\.row:((?:[a-z][a-z0-9_]*|\\*)\\/[a-z][a-z0-9_]*|\\/\\*|\\/\\*\\*)\\.(\\d+|\\*)\\.([a-z][a-z0-9_]*|\\*)\\.(\\d+|\\*)$',
            title='TruthOptionOracleRollableRowIdWildcard',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class WebUrl(RootModel[AnyUrl]):
    root: Annotated[
        AnyUrl,
        Field(description="An absolute URL pointing to a website.", title="WebUrl"),
    ]


class DataswornV010(RootModel[RulesPackage]):
    root: Annotated[
        RulesPackage,
        Field(
            description="Describes game rules compatible with the Ironsworn tabletop role-playing game by Shawn Tomkin.",
            title="Datasworn v0.1.0",
=======
WebpImageUrl = Annotated[
        str,
        Field(
            description='A relative (local) URL pointing to a raster image in the WEBP format.',
            pattern='\\.webp$',
            title='WebpImageUrl',
        ),
    ]


DataswornV010 = Annotated[
        RulesPackage,
        Field(
            description='Describes game rules compatible with the Ironsworn tabletop role-playing game by Shawn Tomkin.',
            title='Datasworn v0.1.0',
>>>>>>> upstream/main
        ),
    ]


class AnyId(
    RootModel[
        AtlasEntryId
        | NpcId
        | NpcVariantId
        | OracleRollableId
        | AssetAbilityOracleRollableId
        | MoveOracleRollableId
        | TruthOptionOracleRollableId
        | OracleRollableRowId
        | AssetAbilityOracleRollableRowId
        | MoveOracleRollableRowId
        | TruthOptionOracleRollableRowId
        | AssetId
        | AssetAbilityId
        | AssetAbilityMoveId
        | MoveId
<<<<<<< HEAD
=======
        | AssetAbilityMoveConditionId
        | MoveConditionId
        | AssetAbilityMoveOutcomeId
        | MoveOutcomeId
>>>>>>> upstream/main
        | AtlasCollectionId
        | NpcCollectionId
        | OracleCollectionId
        | AssetCollectionId
        | MoveCategoryId
        | DelveSiteId
        | DelveSiteDenizenId
        | DelveSiteDomainId
        | DelveSiteDomainFeatureId
        | DelveSiteThemeFeatureId
        | DelveSiteDomainDangerId
        | DelveSiteThemeDangerId
        | DelveSiteThemeId
        | RarityId
        | TruthId
        | TruthOptionId
    ]
):
    root: Annotated[
        AtlasEntryId
        | NpcId
        | NpcVariantId
        | OracleRollableId
        | AssetAbilityOracleRollableId
        | MoveOracleRollableId
        | TruthOptionOracleRollableId
        | OracleRollableRowId
        | AssetAbilityOracleRollableRowId
        | MoveOracleRollableRowId
        | TruthOptionOracleRollableRowId
        | AssetId
        | AssetAbilityId
        | AssetAbilityMoveId
        | MoveId
<<<<<<< HEAD
=======
        | AssetAbilityMoveConditionId
        | MoveConditionId
        | AssetAbilityMoveOutcomeId
        | MoveOutcomeId
>>>>>>> upstream/main
        | AtlasCollectionId
        | NpcCollectionId
        | OracleCollectionId
        | AssetCollectionId
        | MoveCategoryId
        | DelveSiteId
        | DelveSiteDenizenId
        | DelveSiteDomainId
        | DelveSiteDomainFeatureId
        | DelveSiteThemeFeatureId
        | DelveSiteDomainDangerId
        | DelveSiteThemeDangerId
        | DelveSiteThemeId
        | RarityId
        | TruthId
        | TruthOptionId,
        Field(
<<<<<<< HEAD
            description="Represents any kind of non-wildcard ID, including IDs of embedded objects.",
            title="AnyId",
=======
            description='Represents any kind of non-wildcard ID, including IDs of embedded objects.',
            title='AnyId',
>>>>>>> upstream/main
        ),
    ]


<<<<<<< HEAD
class AnyIdWildcard(
    RootModel[
        AtlasEntryIdWildcard
        | NpcIdWildcard
        | NpcVariantIdWildcard
        | OracleRollableIdWildcard
        | AssetAbilityOracleRollableIdWildcard
        | MoveOracleRollableIdWildcard
        | TruthOptionOracleRollableIdWildcard
        | OracleRollableRowIdWildcard
        | AssetAbilityOracleRollableRowIdWildcard
        | MoveOracleRollableRowIdWildcard
        | TruthOptionOracleRollableRowIdWildcard
        | AssetIdWildcard
        | AssetAbilityIdWildcard
        | AssetAbilityMoveIdWildcard
        | MoveIdWildcard
        | AtlasCollectionIdWildcard
        | NpcCollectionIdWildcard
        | OracleCollectionIdWildcard
        | AssetCollectionIdWildcard
        | MoveCategoryIdWildcard
        | DelveSiteIdWildcard
        | DelveSiteDenizenIdWildcard
        | DelveSiteDomainIdWildcard
        | DelveSiteDomainFeatureIdWildcard
        | DelveSiteThemeFeatureIdWildcard
        | DelveSiteDomainDangerIdWildcard
        | DelveSiteThemeDangerIdWildcard
        | DelveSiteThemeIdWildcard
        | RarityIdWildcard
        | TruthIdWildcard
        | TruthOptionIdWildcard
    ]
):
    root: Annotated[
        AtlasEntryIdWildcard
        | NpcIdWildcard
        | NpcVariantIdWildcard
        | OracleRollableIdWildcard
        | AssetAbilityOracleRollableIdWildcard
        | MoveOracleRollableIdWildcard
        | TruthOptionOracleRollableIdWildcard
        | OracleRollableRowIdWildcard
        | AssetAbilityOracleRollableRowIdWildcard
        | MoveOracleRollableRowIdWildcard
        | TruthOptionOracleRollableRowIdWildcard
        | AssetIdWildcard
        | AssetAbilityIdWildcard
        | AssetAbilityMoveIdWildcard
        | MoveIdWildcard
        | AtlasCollectionIdWildcard
        | NpcCollectionIdWildcard
        | OracleCollectionIdWildcard
        | AssetCollectionIdWildcard
        | MoveCategoryIdWildcard
        | DelveSiteIdWildcard
        | DelveSiteDenizenIdWildcard
        | DelveSiteDomainIdWildcard
        | DelveSiteDomainFeatureIdWildcard
        | DelveSiteThemeFeatureIdWildcard
        | DelveSiteDomainDangerIdWildcard
        | DelveSiteThemeDangerIdWildcard
        | DelveSiteThemeIdWildcard
        | RarityIdWildcard
        | TruthIdWildcard
        | TruthOptionIdWildcard,
        Field(
            description="Represents any kind of wildcard ID, including IDs of embedded objects.",
            title="AnyIdWildcard",
        ),
    ]


class AnyMove(RootModel[Move | EmbeddedMove]):
    root: Annotated[Move | EmbeddedMove, Field(title="AnyMove")]


class AnyMoveId(RootModel[MoveId | AssetAbilityMoveId]):
    root: Annotated[MoveId | AssetAbilityMoveId, Field(title="AnyMoveId")]


class AnyMoveIdWildcard(RootModel[MoveIdWildcard | AssetAbilityMoveIdWildcard]):
    root: Annotated[
        MoveIdWildcard | AssetAbilityMoveIdWildcard, Field(title="AnyMoveIdWildcard")
    ]


class AnyOracleRollable(RootModel[OracleRollable | EmbeddedOracleRollable]):
    root: Annotated[
        OracleRollable | EmbeddedOracleRollable, Field(title="AnyOracleRollable")
=======
AnyMove = Annotated[Move | EmbeddedMove, Field(title='AnyMove')]


class AnyMoveConditionIdWildcard(
    RootModel[AssetAbilityMoveConditionIdWildcard | MoveConditionIdWildcard]
):
    root: Annotated[
        AssetAbilityMoveConditionIdWildcard | MoveConditionIdWildcard,
        Field(title='AnyMoveConditionIdWildcard'),
    ]


AnyMoveId = Annotated[MoveId | AssetAbilityMoveId, Field(title='AnyMoveId')]


class AnyMoveOutcomeIdWildcard(
    RootModel[AssetAbilityMoveOutcomeIdWildcard | MoveOutcomeIdWildcard]
):
    root: Annotated[
        AssetAbilityMoveOutcomeIdWildcard | MoveOutcomeIdWildcard,
        Field(title='AnyMoveOutcomeIdWildcard'),
    ]


AnyOracleRollable = Annotated[
        OracleRollable | EmbeddedOracleRollable, Field(title='AnyOracleRollable')
>>>>>>> upstream/main
    ]


class AnyOracleRollableId(
    RootModel[
        OracleRollableId
        | AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId
    ]
):
    root: Annotated[
        OracleRollableId
        | AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
<<<<<<< HEAD
        Field(title="AnyOracleRollableId"),
=======
        Field(title='AnyOracleRollableId'),
>>>>>>> upstream/main
    ]


class AnyOracleRollableIdWildcard(
    RootModel[
        OracleRollableIdWildcard
        | AssetAbilityOracleRollableIdWildcard
        | TruthOptionOracleRollableIdWildcard
        | MoveOracleRollableIdWildcard
    ]
):
    root: Annotated[
        OracleRollableIdWildcard
        | AssetAbilityOracleRollableIdWildcard
        | TruthOptionOracleRollableIdWildcard
        | MoveOracleRollableIdWildcard,
<<<<<<< HEAD
        Field(title="AnyOracleRollableIdWildcard"),
    ]


class AnyOracleRollableRowId(
    RootModel[
        OracleRollableRowId
        | AssetAbilityOracleRollableRowId
        | MoveOracleRollableRowId
        | TruthOptionOracleRollableRowId
    ]
):
    root: Annotated[
        OracleRollableRowId
        | AssetAbilityOracleRollableRowId
        | MoveOracleRollableRowId
        | TruthOptionOracleRollableRowId,
        Field(title="AnyOracleRollableRowId"),
=======
        Field(title='AnyOracleRollableIdWildcard'),
>>>>>>> upstream/main
    ]


class AnyOracleRollableRowIdWildcard(
    RootModel[
        OracleRollableRowIdWildcard
        | AssetAbilityOracleRollableRowIdWildcard
        | MoveOracleRollableRowIdWildcard
        | TruthOptionOracleRollableRowIdWildcard
    ]
):
    root: Annotated[
        OracleRollableRowIdWildcard
        | AssetAbilityOracleRollableRowIdWildcard
        | MoveOracleRollableRowIdWildcard
        | TruthOptionOracleRollableRowIdWildcard,
<<<<<<< HEAD
        Field(title="AnyOracleRollableRowIdWildcard"),
=======
        Field(title='AnyOracleRollableRowIdWildcard'),
>>>>>>> upstream/main
    ]


class AssetAttachment(BaseModel):
    assets: Annotated[
        list[AssetIdWildcard],
        Field(
<<<<<<< HEAD
            description="Asset IDs (which may be wildcards) that may be attached to this asset"
=======
            description='Asset IDs (which may be wildcards) that may be attached to this asset'
>>>>>>> upstream/main
        ),
    ]
    max: Annotated[
        Max | None,
        Field(
            description="Null if there's no upper limit to the number of attached assets."
        ),
    ]


class AssetCardFlipField(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[bool, Field(description="Is the card flipped over?")]
    field_type: Literal["card_flip"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[bool, Field(description='Is the card flipped over?')]
    field_type: Literal['card_flip']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    is_impact: Annotated[
        bool,
        Field(
<<<<<<< HEAD
            description="Does this field count as an impact (Starforged) or debility (Ironsworn classic) when its value is set to `true`?"
=======
            description='Does this field count as an impact (Starforged) or debility (Ironsworn classic) when its value is set to `true`?'
>>>>>>> upstream/main
        ),
    ]
    disables_asset: Annotated[
        bool,
        Field(
<<<<<<< HEAD
            description="Does this field disable the asset when its value is set to `true`?"
=======
            description='Does this field disable the asset when its value is set to `true`?'
>>>>>>> upstream/main
        ),
    ]


class AssetCheckboxField(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[bool, Field(description="Is the box checked?")]
    field_type: Literal["checkbox"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[bool, Field(description='Is the box checked?')]
    field_type: Literal['checkbox']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    is_impact: Annotated[
        bool,
        Field(
<<<<<<< HEAD
            description="Does this field count as an impact (Starforged) or debility (Ironsworn classic) when its value is set to `true`?"
=======
            description='Does this field count as an impact (Starforged) or debility (Ironsworn classic) when its value is set to `true`?'
>>>>>>> upstream/main
        ),
    ]
    disables_asset: Annotated[
        bool,
        Field(
<<<<<<< HEAD
            description="Does this field disable the asset when its value is set to `true`?"
=======
            description='Does this field disable the asset when its value is set to `true`?'
>>>>>>> upstream/main
        ),
    ]


class Moves(BaseModel):
    suffer: Annotated[
<<<<<<< HEAD
        list[AnyMoveIdWildcard] | None,
        Field(
            description="The ID(s) of suffer moves associated with the condition meter. If the suffer move makes an action roll, this condition meter value should be made available as a roll option."
        ),
    ] = None
    recover: Annotated[
        list[AnyMoveIdWildcard] | None,
        Field(description="The ID(s) of recovery moves associated with this meter."),
=======
        list[MoveIdWildcard | AssetAbilityMoveIdWildcard] | None,
        Field(
            description='The ID(s) of suffer moves associated with the condition meter. If the suffer move makes an action roll, this condition meter value should be made available as a roll option.'
        ),
    ] = None
    recover: Annotated[
        list[MoveIdWildcard | AssetAbilityMoveIdWildcard] | None,
        Field(description='The ID(s) of recovery moves associated with this meter.'),
>>>>>>> upstream/main
    ] = None


class AssetConditionMeter(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[int, Field(description="The current value of this meter.")]
    min: Annotated[int, Field(description="The minimum value of this meter.")]
    max: Annotated[int, Field(description="The maximum value of this meter.")]
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[int, Field(description='The current value of this meter.')]
    min: Annotated[int, Field(description='The minimum value of this meter.')]
    max: Annotated[int, Field(description='The maximum value of this meter.')]
>>>>>>> upstream/main
    rollable: Annotated[
        Literal[True],
        Field(
            description="Is this meter's `value` usable as a stat in an action roll?"
        ),
    ]
<<<<<<< HEAD
    field_type: Literal["condition_meter"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
    field_type: Literal['condition_meter']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    moves: Annotated[
        Moves | None,
        Field(
<<<<<<< HEAD
            description="Provides hints for moves that interact with this condition meter, such as suffer and recovery moves."
=======
            description='Provides hints for moves that interact with this condition meter, such as suffer and recovery moves.'
>>>>>>> upstream/main
        ),
    ] = None
    controls: Annotated[
        dict[str, AssetConditionMeterControlField],
<<<<<<< HEAD
        Field(description="Checkbox controls rendered as part of the condition meter."),
=======
        Field(description='Checkbox controls rendered as part of the condition meter.'),
>>>>>>> upstream/main
    ]


class AssetControlValueRef(BaseModel):
    assets: Annotated[
        list[AssetIdWildcard] | None,
        Field(
            description="Asset IDs (which may be wildcarded) that may provide the control field. For asset ability enhancements, `null` is used to represent the asset's own control fields."
        ),
    ]
    control: Annotated[
<<<<<<< HEAD
        DictKey,
        Field(
            description="The dictionary key of the asset control field.",
            examples=["health", "integrity"],
        ),
    ]
    using: Annotated[
        Literal["asset_control"],
        Field(description="A reference to the value of an asset control."),
=======
        str,
        Field(
            description='The dictionary key of the asset control field.',
            examples=['health', 'integrity'],
            pattern='^[a-z][a-z0-9_]*$',
            title='DictKey',
        ),
    ]
    using: Annotated[
        Literal['asset_control'],
        Field(description='A reference to the value of an asset control.'),
>>>>>>> upstream/main
    ]


class AssetOptionValueRef(BaseModel):
    assets: Annotated[
        list[AssetIdWildcard] | None,
        Field(
            description="Asset IDs (which may be wildcarded) that may provide the option field. For asset ability enhancements, `null` is used to represent the asset's own option fields."
        ),
    ]
    option: Annotated[
<<<<<<< HEAD
        DictKey, Field(description="The dictionary key of the asset option field.")
    ]
    using: Annotated[
        Literal["asset_option"],
        Field(description="A reference to the value of an asset option."),
=======
        str,
        Field(
            description='The dictionary key of the asset option field.',
            pattern='^[a-z][a-z0-9_]*$',
            title='DictKey',
        ),
    ]
    using: Annotated[
        Literal['asset_option'],
        Field(description='A reference to the value of an asset option.'),
>>>>>>> upstream/main
    ]


class AttachedAssetControlValueRef(BaseModel):
    control: Annotated[
<<<<<<< HEAD
        DictKey,
        Field(
            description="The dictionary key of the asset control field.",
            examples=["health", "integrity"],
        ),
    ]
    using: Annotated[
        Literal["attached_asset_control"],
        Field(
            description="A reference to the value of an attached asset control. For example, a Module asset could use this to roll using the `integrity` control of an attached Vehicle."
=======
        str,
        Field(
            description='The dictionary key of the asset control field.',
            examples=['health', 'integrity'],
            pattern='^[a-z][a-z0-9_]*$',
            title='DictKey',
        ),
    ]
    using: Annotated[
        Literal['attached_asset_control'],
        Field(
            description='A reference to the value of an attached asset control. For example, a Module asset could use this to roll using the `integrity` control of an attached Vehicle.'
>>>>>>> upstream/main
        ),
    ]


class AttachedAssetOptionValueRef(BaseModel):
    option: Annotated[
<<<<<<< HEAD
        DictKey, Field(description="The dictionary key of the asset option field.")
    ]
    using: Annotated[
        Literal["attached_asset_option"],
        Field(description="A reference to the value of an attached asset option."),
=======
        str,
        Field(
            description='The dictionary key of the asset option field.',
            pattern='^[a-z][a-z0-9_]*$',
            title='DictKey',
        ),
    ]
    using: Annotated[
        Literal['attached_asset_option'],
        Field(description='A reference to the value of an attached asset option.'),
>>>>>>> upstream/main
    ]


class AuthorInfo(BaseModel):
    name: Annotated[
<<<<<<< HEAD
        Label, Field(description="The name of the author.", examples=["Shawn Tomkin"])
    ]
    email: Annotated[
        Email | None, Field(description="An optional email contact for the author")
    ] = None
    url: Annotated[
        WebUrl | None, Field(description="An optional URL for the author's website.")
=======
        str,
        Field(
            description='The name of the author.',
            examples=['Shawn Tomkin'],
            title='Label',
        ),
    ]
    email: Annotated[
        EmailStr | None,
        Field(description='An optional email contact for the author', title='Email'),
    ] = None
    url: Annotated[
        AnyUrl | None,
        Field(description="An optional URL for the author's website.", title='WebUrl'),
>>>>>>> upstream/main
    ] = None


class ClockField(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[int, Field(description="The current value of this input.")]
    min: Annotated[
        Literal[0],
        Field(
            description="The minimum number of filled clock segments. This is always 0."
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[int, Field(description='The current value of this input.')]
    min: Annotated[
        Literal[0],
        Field(
            description='The minimum number of filled clock segments. This is always 0.'
>>>>>>> upstream/main
        ),
    ]
    max: Annotated[
        int,
        Field(
<<<<<<< HEAD
            description="The size of the clock -- in other words, the maximum number of filled clock segments. Standard clocks have 4, 6, 8, or 10 segments.",
            ge=2,
            multiple_of=2.0,
            title="ClockSize",
        ),
    ]
    rollable: Literal[False]
    field_type: Literal["clock"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
            description='The size of the clock -- in other words, the maximum number of filled clock segments. Standard clocks have 4, 6, 8, or 10 segments.',
            ge=2,
            multiple_of=2.0,
            title='ClockSize',
        ),
    ]
    rollable: Literal[False]
    field_type: Literal['clock']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None


class ConditionMeterField(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[int, Field(description="The current value of this meter.")]
    min: Annotated[int, Field(description="The minimum value of this meter.")]
    max: Annotated[int, Field(description="The maximum value of this meter.")]
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[int, Field(description='The current value of this meter.')]
    min: Annotated[int, Field(description='The minimum value of this meter.')]
    max: Annotated[int, Field(description='The maximum value of this meter.')]
>>>>>>> upstream/main
    rollable: Annotated[
        Literal[True],
        Field(
            description="Is this meter's `value` usable as a stat in an action roll?"
        ),
    ]
<<<<<<< HEAD
    field_type: Literal["condition_meter"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
    ] = None


class ConditionMeterKey(RootModel[DictKey]):
    root: Annotated[
        DictKey,
        Field(
            description="A basic, rollable player character resource specified by the ruleset.",
            examples=["health", "spirit", "supply"],
            title="ConditionMeterKey",
=======
    field_type: Literal['condition_meter']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None


ConditionMeterKey = Annotated[
        str,
        Field(
            description='A basic, rollable player character resource specified by the ruleset.',
            examples=['health', 'spirit', 'supply'],
            pattern='^[a-z][a-z0-9_]*$',
            title='ConditionMeterKey',
>>>>>>> upstream/main
        ),
    ]


class ConditionMeterRule(BaseModel):
    description: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="A description of this condition meter.")
    ]
    shared: Annotated[
        bool, Field(description="Is this condition meter shared by all players?")
    ]
    tags: Tags | None = None
    label: Label
    value: Annotated[int, Field(description="The current value of this meter.")]
    min: Annotated[int, Field(description="The minimum value of this meter.")]
    max: Annotated[int, Field(description="The maximum value of this meter.")]
=======
        str,
        Field(
            description='A description of this condition meter.', title='MarkdownString'
        ),
    ]
    shared: Annotated[
        bool, Field(description='Is this condition meter shared by all players?')
    ]
    tags: Tags | None = None
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[int, Field(description='The current value of this meter.')]
    min: Annotated[int, Field(description='The minimum value of this meter.')]
    max: Annotated[int, Field(description='The maximum value of this meter.')]
>>>>>>> upstream/main
    rollable: Annotated[
        Literal[True],
        Field(
            description="Is this meter's `value` usable as a stat in an action roll?"
        ),
    ]


class ConditionMeterValueRef(BaseModel):
<<<<<<< HEAD
    condition_meter: ConditionMeterKey
    using: Annotated[
        Literal["condition_meter"],
        Field(
            description="A reference to the value of a standard player condition meter."
=======
    condition_meter: Annotated[
        str,
        Field(
            description='A basic, rollable player character resource specified by the ruleset.',
            examples=['health', 'spirit', 'supply'],
            pattern='^[a-z][a-z0-9_]*$',
            title='ConditionMeterKey',
        ),
    ]
    using: Annotated[
        Literal['condition_meter'],
        Field(
            description='A reference to the value of a standard player condition meter.'
>>>>>>> upstream/main
        ),
    ]


class CounterField(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[int, Field(description="The current value of this input.")]
    min: Annotated[int, Field(description="The (inclusive) minimum value.")]
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[int, Field(description='The current value of this input.')]
    min: Annotated[int, Field(description='The (inclusive) minimum value.')]
>>>>>>> upstream/main
    max: Annotated[
        int | None,
        Field(
            description="The (inclusive) maximum value, or `null` if there's no maximum."
        ),
    ]
    rollable: Literal[False]
<<<<<<< HEAD
    field_type: Literal["counter"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
    field_type: Literal['counter']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None


class CustomValue(BaseModel):
<<<<<<< HEAD
    label: Label
    value: int
    using: Annotated[
        Literal["custom"],
        Field(description="An arbitrary static integer value with a label."),
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: int
    using: Annotated[
        Literal['custom'],
        Field(description='An arbitrary static integer value with a label.'),
>>>>>>> upstream/main
    ]


class DelveSiteDenizen(BaseModel):
    name: Annotated[
<<<<<<< HEAD
        Label | None,
        Field(
            description="A name for the denizen, if it's different than the `name` property of the NPC."
        ),
    ] = None
    npc: Annotated[
        NpcId | None,
        Field(description="The ID of the relevant NPC entry, if one is specified."),
    ] = None
    frequency: DelveSiteDenizenFrequency
    roll: DiceRange
    field_id: Annotated[DelveSiteDenizenId | None, Field(alias="_id")] = None


class EmbeddedOracleRollableId(
    RootModel[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId
    ]
):
    root: Annotated[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
        Field(title="EmbeddedOracleRollableId"),
    ]
=======
        str | None,
        Field(
            description="A name for the denizen, if it's different than the `name` property of the NPC.",
            title='Label',
        ),
    ] = None
    npc: Annotated[
        str | None,
        Field(
            description='The ID of the relevant NPC entry, if one is specified.',
            pattern='^npc:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='NpcId',
        ),
    ] = None
    frequency: DelveSiteDenizenFrequency
    roll: DiceRange
    id: Annotated[
        str | None,
        Field(
            alias='_id',
            description='A unique ID representing a DelveSiteDenizen object.',
            pattern='^delve_site\\.denizen:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteDenizenId',
        ),
    ] = None
>>>>>>> upstream/main


class EmbeddedOracleRollableIdWildcard(
    RootModel[
        AssetAbilityOracleRollableIdWildcard
        | TruthOptionOracleRollableIdWildcard
        | MoveOracleRollableIdWildcard
    ]
):
    root: Annotated[
        AssetAbilityOracleRollableIdWildcard
        | TruthOptionOracleRollableIdWildcard
        | MoveOracleRollableIdWildcard,
<<<<<<< HEAD
        Field(title="EmbeddedOracleRollableIdWildcard"),
=======
        Field(title='EmbeddedOracleRollableIdWildcard'),
>>>>>>> upstream/main
    ]


class ColumnLabels(BaseModel):
<<<<<<< HEAD
    roll: Label
    text: Label


class ColumnLabels1(BaseModel):
    roll: Label
    text: Label
    text2: Label


class ColumnLabels2(BaseModel):
    roll: Label
    text: Label
    text2: Label
    text3: Label


class EntityPrompt(BaseModel):
    text: MarkdownString
=======
    roll: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels1(BaseModel):
    roll: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text2: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class ColumnLabels2(BaseModel):
    roll: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text2: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    text3: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]


class EntityPrompt(BaseModel):
    text: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
>>>>>>> upstream/main


class I18nHint(BaseModel):
    part_of_speech: Annotated[
<<<<<<< HEAD
        PartOfSpeech | None, Field(description="The part of speech for this string.")
=======
        PartOfSpeech | None, Field(description='The part of speech for this string.')
>>>>>>> upstream/main
    ] = None


class Template8(BaseModel):
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None


class I18nHints(BaseModel):
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


class ImpactRule(BaseModel):
<<<<<<< HEAD
    label: Annotated[Label, Field(description="The label for this impact.")]
    description: Annotated[
        MarkdownString, Field(description="A description of this impact.")
    ]
    shared: Annotated[
        bool, Field(description="Is this impact applied to all players at once?")
=======
    label: Annotated[
        str, Field(description='The label for this impact.', title='Label')
    ]
    description: Annotated[
        str, Field(description='A description of this impact.', title='MarkdownString')
    ]
    shared: Annotated[
        bool, Field(description='Is this impact applied to all players at once?')
>>>>>>> upstream/main
    ]
    prevents_recovery: Annotated[
        list[ConditionMeterKey],
        Field(
<<<<<<< HEAD
            description="Any ruleset condition meters that can't recover when this impact is active."
        ),
    ]
    permanent: Annotated[bool, Field(description="Is this impact permanent?")]
=======
            default_factory=list,
            description="Any ruleset condition meters that can't recover when this impact is active.",
        ),
    ]
    permanent: Annotated[bool, Field(description='Is this impact permanent?')]
>>>>>>> upstream/main
    tags: Tags | None = None


class MoveNoRollEnhancement(BaseModel):
    enhances: Annotated[
<<<<<<< HEAD
        list[AnyMoveIdWildcard] | None,
        Field(
            description="An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid."
        ),
    ]
    roll_type: Annotated[
        Literal["no_roll"],
        Field(
            description="A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties."
=======
        list[MoveIdWildcard | AssetAbilityMoveIdWildcard] | None,
        Field(
            description='An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid.'
        ),
    ]
    roll_type: Annotated[
        Literal['no_roll'],
        Field(
            description='A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties.'
>>>>>>> upstream/main
        ),
    ]
    trigger: TriggerNoRollEnhancement | None = None


class MoveProgressRollEnhancement(BaseModel):
    enhances: Annotated[
<<<<<<< HEAD
        list[AnyMoveIdWildcard] | None,
        Field(
            description="An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid."
        ),
    ]
    roll_type: Annotated[
        Literal["progress_roll"],
        Field(
            description="A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties."
=======
        list[MoveIdWildcard | AssetAbilityMoveIdWildcard] | None,
        Field(
            description='An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid.'
        ),
    ]
    roll_type: Annotated[
        Literal['progress_roll'],
        Field(
            description='A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties.'
>>>>>>> upstream/main
        ),
    ]
    trigger: TriggerProgressRollEnhancement | None = None


class NpcVariant(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        NpcVariantId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Label
    rank: Annotated[
        ChallengeRank, Field(description="The suggested challenge rank for this NPC.")
    ]
    nature: NpcNature
    summary: MarkdownString | None = None
    description: MarkdownString
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^npc\\.variant:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.([a-z][a-z0-9_]*|\\*)$',
            title='NpcVariantId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    rank: Annotated[
        ChallengeRank, Field(description='The suggested challenge rank for this NPC.')
    ]
    nature: Annotated[
        str,
        Field(
            description="A localized category label describing the nature of this NPC.\n\nIn Ironsworn classic, this is probably the singular form of the parent collection's name.\n\nFor Starforged, see the table on p. 258 for examples.",
            examples=[
                'Ironlander',
                'Firstborn',
                'Animal',
                'Beast',
                'Horror',
                'Anomaly',
                'Creature',
                'Human',
                'Machine',
                'Monster',
                'Vehicle',
            ],
            title='NpcNature',
        ),
    ]
    summary: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
>>>>>>> upstream/main


class OracleRoll(BaseModel):
    oracle: Annotated[
        OracleRollableId | None,
        Field(
            description="The ID of the oracle to be rolled. A `null` value indicates that it's a roll on the same table."
        ),
    ]
    auto: Annotated[
        bool,
        Field(
            description='Both Ironsworn and Starforged explicitly recommend *against* rolling all details at once. That said, some oracle results only provide useful information once a secondary roll occurs, such as "Action + Theme" or "Roll twice".'
        ),
    ]
    duplicates: Annotated[
        OracleDuplicateBehavior,
        Field(
<<<<<<< HEAD
            description="Special rules on how to handle duplicate results, when rolling multiple times."
=======
            description='Special rules on how to handle duplicate results, when rolling multiple times.'
>>>>>>> upstream/main
        ),
    ]
    dice: Annotated[
        DiceExpression | None,
        Field(
            description="The dice roll to make on the oracle table. Set it to `null` if you just want the table's default."
        ),
    ]
    number_of_rolls: Annotated[
<<<<<<< HEAD
        int, Field(description="The number of times to roll.", ge=1)
    ]


class FieldI18n4(BaseModel):
=======
        int, Field(description='The number of times to roll.', ge=1)
    ]


class I18n4(BaseModel):
>>>>>>> upstream/main
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


<<<<<<< HEAD
class FieldI18n5(BaseModel):
=======
class I18n5(BaseModel):
>>>>>>> upstream/main
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


<<<<<<< HEAD
class FieldI18n6(BaseModel):
=======
class I18n6(BaseModel):
>>>>>>> upstream/main
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


class SelectEnhancementField(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[
        DictKey | None,
        Field(
            description="The key of the currently selected choice from the `choices` property, or `null` if none is selected."
        ),
    ]
    choices: dict[str, Choices]
    field_type: Literal["select_enhancement"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[
        DictKey | None,
        Field(
            description='The key of the currently selected choice from the `choices` property, or `null` if none is selected.'
        ),
    ]
    choices: dict[str, Choices]
    field_type: Literal['select_enhancement']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None


class SelectValueField(BaseModel):
<<<<<<< HEAD
    label: Label
    value: Annotated[
        DictKey | None,
        Field(
            description="The key of the currently selected choice from the `choices` property, or `null` if none is selected."
        ),
    ]
    choices: dict[str, SelectValueFieldChoice]
    field_type: Literal["select_value"]
    icon: Annotated[
        SvgImageUrl | None, Field(description="An icon associated with this input.")
=======
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    value: Annotated[
        DictKey | None,
        Field(
            description='The key of the currently selected choice from the `choices` property, or `null` if none is selected.'
        ),
    ]
    choices: dict[str, SelectValueFieldChoice]
    field_type: Literal['select_value']
    icon: Annotated[
        str | None,
        Field(
            description='An icon associated with this input.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None


class SourceInfo(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    title: Annotated[
        Label,
        Field(
            description="The title of the source document.",
            examples=[
                "Ironsworn Rulebook",
                "Ironsworn Assets Master Set",
                "Ironsworn: Delve",
                "Ironsworn: Starforged Rulebook",
                "Ironsworn: Starforged Assets",
                "Sundered Isles",
            ],
        ),
    ]
    page: Annotated[
        PageNumber | None,
        Field(description="The page number where this content is described in full."),
=======
        extra='allow',
    )
    title: Annotated[
        str,
        Field(
            description='The title of the source document.',
            examples=[
                'Ironsworn Rulebook',
                'Ironsworn Assets Master Set',
                'Ironsworn: Delve',
                'Ironsworn: Starforged Rulebook',
                'Ironsworn: Starforged Assets',
                'Sundered Isles',
            ],
            title='Label',
        ),
    ]
    page: Annotated[
        int | None,
        Field(
            description='The page number where this content is described in full.',
            ge=1,
            title='PageNumber',
        ),
>>>>>>> upstream/main
    ] = None
    authors: Annotated[
        list[AuthorInfo],
        Field(
<<<<<<< HEAD
            description="Lists authors credited by the source material.", min_length=1
=======
            description='Lists authors credited by the source material.', min_length=1
>>>>>>> upstream/main
        ),
    ]
    date: Annotated[
        date_aliased,
        Field(
            description="The date of the source documents's last update, formatted YYYY-MM-DD. Required because it's used to determine whether the data needs updating.",
<<<<<<< HEAD
            # pattern='[0-9]{4}-((0[0-9])|(1[0-2]))-(([0-2][0-9])|(3[0-1]))',
        ),
    ]
    url: Annotated[
        WebUrl,
        Field(
            description="A URL where the source document is available.",
            examples=["https://ironswornrpg.com"],
        ),
    ]
    license: Annotated[
        WebUrl | None,
        Field(
            description="An URL pointing to the location where this content's license can be found.\n\nA `null` here indicates that the content provides __no__ license, and is not intended for redistribution.",
            examples=[
                "https://creativecommons.org/licenses/by/4.0",
                "https://creativecommons.org/licenses/by-nc-sa/4.0",
=======
        ),
    ]
    url: Annotated[
        AnyUrl,
        Field(
            description='A URL where the source document is available.',
            examples=['https://ironswornrpg.com'],
            title='WebUrl',
        ),
    ]
    license: Annotated[
        AnyUrl | None,
        Field(
            description="An URL pointing to the location where this content's license can be found.\n\nA `null` here indicates that the content provides __no__ license, and is not intended for redistribution.",
            examples=[
                'https://creativecommons.org/licenses/by/4.0',
                'https://creativecommons.org/licenses/by-nc-sa/4.0',
>>>>>>> upstream/main
            ],
        ),
    ]


<<<<<<< HEAD
class Suggestions(RootModel[list[AnyIdWildcard]]):
    root: Annotated[list[AnyIdWildcard], Field(title="Suggestions")]


=======
>>>>>>> upstream/main
class Tag(
    RootModel[
        bool
        | int
        | DictKey
        | DiceExpression
        | AtlasEntryId
        | NpcId
        | OracleRollableId
        | AssetId
        | MoveId
        | AtlasCollectionId
        | NpcCollectionId
        | OracleCollectionId
        | AssetCollectionId
        | MoveCategoryId
        | DelveSiteId
        | DelveSiteDomainId
        | DelveSiteThemeId
        | RarityId
        | TruthId
        | list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | OracleRollableIdWildcard
            | AssetIdWildcard
            | MoveIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
        ]
    ]
):
    root: Annotated[
        bool
        | int
        | DictKey
        | DiceExpression
        | AtlasEntryId
        | NpcId
        | OracleRollableId
        | AssetId
        | MoveId
        | AtlasCollectionId
        | NpcCollectionId
        | OracleCollectionId
        | AssetCollectionId
        | MoveCategoryId
        | DelveSiteId
        | DelveSiteDomainId
        | DelveSiteThemeId
        | RarityId
        | TruthId
        | list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | OracleRollableIdWildcard
            | AssetIdWildcard
            | MoveIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
        ],
<<<<<<< HEAD
        Field(title="Tag"),
    ]


class Type1(RootModel[list[SimpleTypes]]):
    root: Annotated[list[SimpleTypes], Field(min_length=1)]


class TriggerActionRollCondition(BaseModel):
    text: Annotated[
        MarkdownString | None,
        Field(
            description="A markdown string of any trigger text specific to this trigger condition."
=======
        Field(title='Tag'),
    ]


Type1 = Annotated[list[SimpleTypes], Field(min_length=1)]


class TriggerActionRollCondition(BaseModel):
    id: Annotated[
        AssetAbilityMoveConditionId | MoveConditionId,
        Field(alias='_id', title='AnyMoveConditionId'),
    ]
    text: Annotated[
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    by: TriggerBy | None = None
    method: ActionRollMethod
    roll_options: Annotated[
        list[RollableValue],
        Field(
<<<<<<< HEAD
            description="The options available when rolling with this trigger condition."
=======
            description='The options available when rolling with this trigger condition.'
>>>>>>> upstream/main
        ),
    ]


class TriggerActionRollConditionEnhancement(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description="A markdown string of any trigger text specific to this trigger condition."
=======
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    by: TriggerBy | None = None
    method: Annotated[
        ActionRollMethod | None,
        Field(
<<<<<<< HEAD
            description="A `null` value means this condition provides no roll mechanic of its own; it must be used with another trigger condition that provides a non-null `method`."
=======
            description='A `null` value means this condition provides no roll mechanic of its own; it must be used with another trigger condition that provides a non-null `method`.'
>>>>>>> upstream/main
        ),
    ]
    roll_options: list[RollableValue] | None


class TriggerActionRollEnhancement(BaseModel):
    conditions: Annotated[
        list[TriggerActionRollConditionEnhancement],
<<<<<<< HEAD
        Field(description="Trigger conditions added to the enhanced move."),
    ]


class TriggerNoRoll(BaseModel):
    text: Annotated[
        str,
        Field(
            description="A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions."
        ),
    ]
    conditions: Annotated[
        list[TriggerNoRollCondition],
        Field(description="Specific conditions that qualify for this trigger."),
    ]


class TriggerProgressRoll(BaseModel):
    text: Annotated[
        str,
        Field(
            description="A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions."
        ),
    ]
    conditions: Annotated[
        list[TriggerProgressRollCondition],
        Field(description="Specific conditions that qualify for this trigger."),
=======
        Field(description='Trigger conditions added to the enhanced move.'),
    ]


class TriggerNoRollCondition(BaseModel):
    id: Annotated[
        AssetAbilityMoveConditionId | MoveConditionId,
        Field(alias='_id', title='AnyMoveConditionId'),
    ]
    text: Annotated[
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
        ),
    ] = None
    by: TriggerBy | None = None
    method: None
    roll_options: Annotated[
        None,
        Field(
            description='The options available when rolling with this trigger condition.'
        ),
    ]


class TriggerProgressRollCondition(BaseModel):
    id: Annotated[
        AssetAbilityMoveConditionId | MoveConditionId,
        Field(alias='_id', title='AnyMoveConditionId'),
    ]
    text: Annotated[
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
        ),
    ] = None
    by: TriggerBy | None = None
    method: ProgressRollMethod
    roll_options: Annotated[
        list[ProgressRollOption],
        Field(
            description='The options available when rolling with this trigger condition.'
        ),
>>>>>>> upstream/main
    ]


class TriggerSpecialTrackCondition(BaseModel):
<<<<<<< HEAD
    text: Annotated[
        MarkdownString | None,
        Field(
            description="A markdown string of any trigger text specific to this trigger condition."
=======
    id: Annotated[
        AssetAbilityMoveConditionId | MoveConditionId,
        Field(alias='_id', title='AnyMoveConditionId'),
    ]
    text: Annotated[
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    by: TriggerBy | None = None
    method: SpecialTrackRollMethod
    roll_options: Annotated[
        list[TriggerSpecialTrackConditionOption],
        Field(
<<<<<<< HEAD
            description="The options available when rolling with this trigger condition."
=======
            description='The options available when rolling with this trigger condition.'
>>>>>>> upstream/main
        ),
    ]


class TriggerSpecialTrackConditionEnhancement(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description="A markdown string of any trigger text specific to this trigger condition."
=======
        str | None,
        Field(
            description='A markdown string of any trigger text specific to this trigger condition.',
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    by: TriggerBy | None = None
    method: Annotated[
        SpecialTrackRollMethod | None,
        Field(
<<<<<<< HEAD
            description="A `null` value means this condition provides no roll mechanic of its own; it must be used with another trigger condition that provides a non-null `method`."
=======
            description='A `null` value means this condition provides no roll mechanic of its own; it must be used with another trigger condition that provides a non-null `method`.'
>>>>>>> upstream/main
        ),
    ]
    roll_options: list[TriggerSpecialTrackConditionOption] | None


class TriggerSpecialTrackEnhancement(BaseModel):
    conditions: Annotated[
        list[TriggerSpecialTrackConditionEnhancement],
<<<<<<< HEAD
        Field(description="Trigger conditions added to the enhanced move."),
=======
        Field(description='Trigger conditions added to the enhanced move.'),
>>>>>>> upstream/main
    ]


class TruthOption(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        TruthOptionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    roll: DiceRange
    summary: MarkdownString | None = None
    description: MarkdownString
    quest_starter: MarkdownString
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title="TruthOptionOracles")
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^truth\\.option:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='TruthOptionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    roll: DiceRange
    summary: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
    quest_starter: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title='TruthOptionOracles')
>>>>>>> upstream/main
    ] = {}


class AssetEnhancement(BaseModel):
    controls: Annotated[
        dict[str, AssetControlFieldEnhancement] | None,
        Field(
<<<<<<< HEAD
            description="Controls are condition meters, clocks, counters, and other asset input fields whose values are expected to change throughout the life of the asset."
        ),
    ] = None
    suggestions: Suggestions | None = None
    count_as_impact: Annotated[
        bool | None,
        Field(
            description="If `true`, this asset counts as an impact (Starforged) or a debility (classic Ironsworn)."
=======
            description='Controls are condition meters, clocks, counters, and other asset input fields whose values are expected to change throughout the life of the asset.'
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    count_as_impact: Annotated[
        bool | None,
        Field(
            description='If `true`, this asset counts as an impact (Starforged) or a debility (classic Ironsworn).'
>>>>>>> upstream/main
        ),
    ] = None
    attachments: AssetAttachment | None = None
    shared: Annotated[
        bool | None,
        Field(
            description="Most assets only benefit to their owner, but certain assets (like Starforged's module and command vehicle assets) are shared amongst the player's allies, too."
        ),
    ] = None


class AtlasEntry(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        AtlasEntryId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Label
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^atlas_entry:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='AtlasEntryId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[AtlasEntryIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    features: list[MarkdownString]
    summary: MarkdownString | None = None
    description: MarkdownString
    quest_starter: MarkdownString | None = None
    your_truth: MarkdownString | None = None
    type: Literal["atlas_entry"]


class DelveSite(BaseModel):
    field_id: Annotated[
        DelveSiteId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    features: list[str]
    summary: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
    quest_starter: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    your_truth: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    type: Literal['atlas_entry']


class DelveSite(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^delve_site:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[DelveSiteIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    rank: ChallengeRank
    region: Annotated[
        AtlasEntryId | None,
        Field(
            description="The ID of an atlas entry representing the region in which this delve site is located."
        ),
    ] = None
    theme: Annotated[
        DelveSiteThemeId, Field(description="The ID of the site's DelveSiteTheme card.")
    ]
    domain: Annotated[
        DelveSiteDomainId,
        Field(description="The ID of the site's DelveSiteDomain card."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    rank: ChallengeRank
    region: Annotated[
        str | None,
        Field(
            description='The ID of an atlas entry representing the region in which this delve site is located.',
            pattern='^atlas_entry:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='AtlasEntryId',
        ),
    ] = None
    theme: Annotated[
        str,
        Field(
            description="The ID of the site's DelveSiteTheme card.",
            pattern='^delve_site_theme:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteThemeId',
        ),
    ]
    domain: Annotated[
        str,
        Field(
            description="The ID of the site's DelveSiteDomain card.",
            pattern='^delve_site_domain:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteDomainId',
        ),
>>>>>>> upstream/main
    ]
    extra_card: Annotated[
        DelveSiteThemeId | DelveSiteDomainId | None,
        Field(
<<<<<<< HEAD
            description="An additional theme or domain card ID, for use with optional rules in Ironsworn: Delve."
        ),
    ] = None
    description: MarkdownString
    denizens: Annotated[
        list[Denizens],
=======
            description='An additional theme or domain card ID, for use with optional rules in Ironsworn: Delve.'
        ),
    ] = None
    description: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
    denizens: Annotated[
        list[DelveSiteDenizen],
>>>>>>> upstream/main
        Field(
            description="Represents the delve site's denizen matrix as an array of objects."
        ),
    ]
<<<<<<< HEAD
    type: Literal["delve_site"]


class DelveSiteDomain(BaseModel):
    field_id: Annotated[
        DelveSiteDomainId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    type: Literal['delve_site']


class DelveSiteDomain(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^delve_site_domain:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteDomainId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[DelveSiteDomainIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    summary: Annotated[
        MarkdownString,
        Field(description="The text that appears below the title on the card."),
    ]
    descriptipn: Annotated[
        MarkdownString | None, Field(description="Optional extended description text.")
    ] = None
    name_oracle: Annotated[
        OracleRollableId | None,
        Field(
            description="An oracle table ID containing place name elements. For examples, see oracle ID `oracle_rollable:delve/site_name/place/barrow`, and its siblings in oracle collection ID `oracle_collection:delve/site_name/place`. These oracles are used by the site name oracle from Ironsworn: Delve (`oracle_rollable:delve/site_name/format`) to create random names for delve sites."
        ),
    ] = None
    features: list[Features]
    dangers: list[Dangers]
    type: Literal["delve_site_domain"]


class FieldI18n(BaseModel):
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    summary: Annotated[
        str,
        Field(
            description='The text that appears below the title on the card.',
            title='MarkdownString',
        ),
    ]
    descriptipn: Annotated[
        str | None,
        Field(
            description='Optional extended description text.', title='MarkdownString'
        ),
    ] = None
    name_oracle: Annotated[
        str | None,
        Field(
            description='An oracle table ID containing place name elements. For examples, see oracle ID `oracle_rollable:delve/site_name/place/barrow`, and its siblings in oracle collection ID `oracle_collection:delve/site_name/place`. These oracles are used by the site name oracle from Ironsworn: Delve (`oracle_rollable:delve/site_name/format`) to create random names for delve sites.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
        ),
    ] = None
    features: list[DelveSiteDomainFeature]
    dangers: list[DelveSiteDomainDanger]
    type: Literal['delve_site_domain']


class I18n(BaseModel):
>>>>>>> upstream/main
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


class DelveSiteDomainDanger(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="The primary text content of this row.")
    ]
    icon: SvgImageUrl | None = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description="Further oracle rolls prompted by this table row."),
    ] = None
    suggestions: Suggestions | None = None
    embed_table: Annotated[
        str | None,
        Field(
            description="Hints that the identified table should be rendered inside this table row."
        ),
    ] = None
    template: Template | None = None
    field_i18n: Annotated[FieldI18n | None, Field(alias="_i18n")] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description="`null` represents an unrollable row, included only for rendering purposes."
        ),
    ]
    tags: Tags | None = None
    field_id: Annotated[DelveSiteDomainDangerId, Field(alias="_id")]


class FieldI18n1(BaseModel):
=======
        str,
        Field(
            description='The primary text content of this row.', title='MarkdownString'
        ),
    ]
    icon: Annotated[
        str | None,
        Field(
            description='A relative (local) URL pointing to a vector image in the SVG format.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description='Further oracle rolls prompted by this table row.'),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    embed_table: Annotated[
        str | None,
        Field(
            description='Hints that the identified table should be rendered inside this table row.'
        ),
    ] = None
    template: Template | None = None
    i18n: Annotated[I18n | None, Field(alias='_i18n')] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description='`null` represents an unrollable row, included only for rendering purposes.'
        ),
    ]
    tags: Tags | None = None
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing a DelveSiteDomainDanger object.',
            pattern='^delve_site_domain\\.danger:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteDomainDangerId',
        ),
    ]


class I18n1(BaseModel):
>>>>>>> upstream/main
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


class DelveSiteDomainFeature(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="The primary text content of this row.")
    ]
    icon: SvgImageUrl | None = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description="Further oracle rolls prompted by this table row."),
    ] = None
    suggestions: Suggestions | None = None
    embed_table: Annotated[
        str | None,
        Field(
            description="Hints that the identified table should be rendered inside this table row."
        ),
    ] = None
    template: Template | None = None
    field_i18n: Annotated[FieldI18n1 | None, Field(alias="_i18n")] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description="`null` represents an unrollable row, included only for rendering purposes."
        ),
    ]
    tags: Tags | None = None
    field_id: Annotated[DelveSiteDomainFeatureId, Field(alias="_id")]


class DelveSiteTheme(BaseModel):
    field_id: Annotated[
        DelveSiteThemeId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
        str,
        Field(
            description='The primary text content of this row.', title='MarkdownString'
        ),
    ]
    icon: Annotated[
        str | None,
        Field(
            description='A relative (local) URL pointing to a vector image in the SVG format.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description='Further oracle rolls prompted by this table row.'),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    embed_table: Annotated[
        str | None,
        Field(
            description='Hints that the identified table should be rendered inside this table row.'
        ),
    ] = None
    template: Template | None = None
    i18n: Annotated[I18n1 | None, Field(alias='_i18n')] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description='`null` represents an unrollable row, included only for rendering purposes.'
        ),
    ]
    tags: Tags | None = None
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing a DelveSiteDomainFeature object.',
            pattern='^delve_site_domain\\.feature:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteDomainFeatureId',
        ),
    ]


class DelveSiteTheme(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^delve_site_theme:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='DelveSiteThemeId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[DelveSiteThemeIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    summary: Annotated[
        MarkdownString,
        Field(description="The text that appears below the title on the card."),
    ]
    descriptipn: Annotated[
        MarkdownString | None, Field(description="Optional extended description text.")
    ] = None
    features: list[Features]
    dangers: list[Dangers]
    type: Literal["delve_site_theme"]


class FieldI18n2(BaseModel):
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    summary: Annotated[
        str,
        Field(
            description='The text that appears below the title on the card.',
            title='MarkdownString',
        ),
    ]
    descriptipn: Annotated[
        str | None,
        Field(
            description='Optional extended description text.', title='MarkdownString'
        ),
    ] = None
    features: list[DelveSiteThemeFeature]
    dangers: list[DelveSiteThemeDanger]
    type: Literal['delve_site_theme']


class I18n2(BaseModel):
>>>>>>> upstream/main
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


class DelveSiteThemeDanger(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="The primary text content of this row.")
    ]
    icon: SvgImageUrl | None = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description="Further oracle rolls prompted by this table row."),
    ] = None
    suggestions: Suggestions | None = None
    embed_table: Annotated[
        str | None,
        Field(
            description="Hints that the identified table should be rendered inside this table row."
        ),
    ] = None
    template: Template | None = None
    field_i18n: Annotated[FieldI18n2 | None, Field(alias="_i18n")] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description="`null` represents an unrollable row, included only for rendering purposes."
        ),
    ]
    tags: Tags | None = None
    field_id: Annotated[DelveSiteThemeDangerId, Field(alias="_id")]


class FieldI18n3(BaseModel):
=======
        str,
        Field(
            description='The primary text content of this row.', title='MarkdownString'
        ),
    ]
    icon: Annotated[
        str | None,
        Field(
            description='A relative (local) URL pointing to a vector image in the SVG format.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description='Further oracle rolls prompted by this table row.'),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    embed_table: Annotated[
        str | None,
        Field(
            description='Hints that the identified table should be rendered inside this table row.'
        ),
    ] = None
    template: Template | None = None
    i18n: Annotated[I18n2 | None, Field(alias='_i18n')] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description='`null` represents an unrollable row, included only for rendering purposes.'
        ),
    ]
    tags: Tags | None = None
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing a DelveSiteThemeDanger object.',
            pattern='^delve_site_theme\\.danger:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteThemeDangerId',
        ),
    ]


class I18n3(BaseModel):
>>>>>>> upstream/main
    text: I18nHint | None = None
    text2: I18nHint | None = None
    text3: I18nHint | None = None
    template: Template8 | None = None


class DelveSiteThemeFeature(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="The primary text content of this row.")
    ]
    icon: SvgImageUrl | None = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description="Further oracle rolls prompted by this table row."),
    ] = None
    suggestions: Suggestions | None = None
    embed_table: Annotated[
        str | None,
        Field(
            description="Hints that the identified table should be rendered inside this table row."
        ),
    ] = None
    template: Template | None = None
    field_i18n: Annotated[FieldI18n3 | None, Field(alias="_i18n")] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description="`null` represents an unrollable row, included only for rendering purposes."
        ),
    ]
    tags: Tags | None = None
    field_id: Annotated[DelveSiteThemeFeatureId, Field(alias="_id")]


class EmbeddedNoRollMove(BaseModel):
    field_id: Annotated[EmbeddedMoveId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    trigger: Annotated[
        TriggerNoRoll,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[None, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["no_roll"]


class ImpactCategory(BaseModel):
    label: Annotated[Label, Field(description="A label for this impact category.")]
    description: Annotated[
        MarkdownString, Field(description="A description of this impact category.")
    ]
    contents: Annotated[
        dict[str, ImpactRule],
        Field(description="A dictionary object of the Impacts in this category."),
=======
        str,
        Field(
            description='The primary text content of this row.', title='MarkdownString'
        ),
    ]
    icon: Annotated[
        str | None,
        Field(
            description='A relative (local) URL pointing to a vector image in the SVG format.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description='Further oracle rolls prompted by this table row.'),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    embed_table: Annotated[
        str | None,
        Field(
            description='Hints that the identified table should be rendered inside this table row.'
        ),
    ] = None
    template: Template | None = None
    i18n: Annotated[I18n3 | None, Field(alias='_i18n')] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description='`null` represents an unrollable row, included only for rendering purposes.'
        ),
    ]
    tags: Tags | None = None
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing a DelveSiteThemeFeature object.',
            pattern='^delve_site_theme\\.feature:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)\\.(\\d+)$',
            title='DelveSiteThemeFeatureId',
        ),
    ]


class ImpactCategory(BaseModel):
    label: Annotated[
        str, Field(description='A label for this impact category.', title='Label')
    ]
    description: Annotated[
        str,
        Field(
            description='A description of this impact category.', title='MarkdownString'
        ),
    ]
    contents: Annotated[
        dict[str, ImpactRule],
        Field(description='A dictionary object of the Impacts in this category.'),
>>>>>>> upstream/main
    ]


class MoveActionRollEnhancement(BaseModel):
    enhances: Annotated[
<<<<<<< HEAD
        list[AnyMoveIdWildcard] | None,
        Field(
            description="An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid."
        ),
    ]
    roll_type: Annotated[
        Literal["action_roll"],
        Field(
            description="A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties."
=======
        list[MoveIdWildcard | AssetAbilityMoveIdWildcard] | None,
        Field(
            description='An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid.'
        ),
    ]
    roll_type: Annotated[
        Literal['action_roll'],
        Field(
            description='A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties.'
>>>>>>> upstream/main
        ),
    ]
    trigger: TriggerActionRollEnhancement | None = None


class MoveCategory(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        MoveCategoryId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^move_category:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='MoveCategoryId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[MoveCategoryIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[MoveCategoryIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
        ),
    ] = None
    contents: dict[str, Move]
    collections: dict[str, MoveCategory]
    type: Literal["move_category"]


class MoveNoRoll(BaseModel):
    field_id: Annotated[
        MoveId, Field(alias="_id", description="The unique Datasworn ID for this node.")
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    replaces: Annotated[
        list[MoveIdWildcard] | None,
        Field(
            description="Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title="MoveOracles")
    ] = {}
    trigger: Annotated[
        TriggerNoRoll,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[None, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["no_roll"]


class MoveOutcome(BaseModel):
    text: MarkdownString
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
        ),
    ] = None
    contents: dict[str, Annotated[MoveActionRoll | MoveNoRoll | MoveProgressRoll | MoveSpecialTrack, Discriminator('roll_type')]]
    collections: dict[str, MoveCategory]
    type: Literal['move_category']


class MoveOutcome(BaseModel):
    id: Annotated[
        AssetAbilityMoveOutcomeId | MoveOutcomeId,
        Field(alias='_id', title='AnyMoveOutcomeId'),
    ]
    text: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
>>>>>>> upstream/main
    oracle_rolls: list[OracleRoll] | None = None


class MoveOutcomes(BaseModel):
    strong_hit: MoveOutcome
    weak_hit: MoveOutcome
    miss: MoveOutcome


<<<<<<< HEAD
class MoveProgressRoll(BaseModel):
    field_id: Annotated[
        MoveId, Field(alias="_id", description="The unique Datasworn ID for this node.")
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    replaces: Annotated[
        list[MoveIdWildcard] | None,
        Field(
            description="Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title="MoveOracles")
    ] = {}
    trigger: Annotated[
        TriggerProgressRoll,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[MoveOutcomes, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["progress_roll"]
    tracks: Annotated[
        ProgressTrackTypeInfo,
        Field(
            description="Describes the common features of progress tracks associated with this move."
        ),
    ]


class MoveSpecialTrackEnhancement(BaseModel):
    enhances: Annotated[
        list[AnyMoveIdWildcard] | None,
        Field(
            description="An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid."
        ),
    ]
    roll_type: Annotated[
        Literal["special_track"],
        Field(
            description="A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties."
=======
class MoveSpecialTrackEnhancement(BaseModel):
    enhances: Annotated[
        list[MoveIdWildcard | AssetAbilityMoveIdWildcard] | None,
        Field(
            description='An array of wildcard IDs. An item must match one of the wildcard IDs to receive this enhancement. If this is `null`, any ID is valid.'
        ),
    ]
    roll_type: Annotated[
        Literal['special_track'],
        Field(
            description='A move must have this `roll_type` to receive this enhancement. This is in addition to any other restrictions made by other properties.'
>>>>>>> upstream/main
        ),
    ]
    trigger: TriggerSpecialTrackEnhancement | None = None


class Npc(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        NpcId, Field(alias="_id", description="The unique Datasworn ID for this node.")
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Label
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^npc:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='NpcId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[NpcIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    features: list[MarkdownString]
    summary: MarkdownString | None = None
    description: MarkdownString
    quest_starter: MarkdownString | None = None
    your_truth: MarkdownString | None = None
    rank: Annotated[
        ChallengeRank, Field(description="The suggested challenge rank for this NPC.")
    ]
    nature: NpcNature
    drives: list[MarkdownString]
    tactics: list[MarkdownString]
    variants: dict[str, NpcVariant]
    type: Literal["npc"]


class NpcCollection(BaseModel):
    field_id: Annotated[
        NpcCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    features: list[str]
    summary: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ]
    quest_starter: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    your_truth: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    rank: Annotated[
        ChallengeRank, Field(description='The suggested challenge rank for this NPC.')
    ]
    nature: Annotated[
        str,
        Field(
            description="A localized category label describing the nature of this NPC.\n\nIn Ironsworn classic, this is probably the singular form of the parent collection's name.\n\nFor Starforged, see the table on p. 258 for examples.",
            examples=[
                'Ironlander',
                'Firstborn',
                'Animal',
                'Beast',
                'Horror',
                'Anomaly',
                'Creature',
                'Human',
                'Machine',
                'Monster',
                'Vehicle',
            ],
            title='NpcNature',
        ),
    ]
    drives: list[str]
    tactics: list[str]
    variants: dict[str, NpcVariant]
    type: Literal['npc']


class NpcCollection(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^npc_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='NpcCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[NpcCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[NpcCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    contents: dict[str, Npc]
    collections: dict[str, NpcCollection]
<<<<<<< HEAD
    type: Literal["npc_collection"]
=======
    type: Literal['npc_collection']
>>>>>>> upstream/main


class OracleRollableRowText(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="The primary text content of this row.")
    ]
    icon: SvgImageUrl | None = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description="Further oracle rolls prompted by this table row."),
    ] = None
    suggestions: Suggestions | None = None
    embed_table: Annotated[
        str | None,
        Field(
            description="Hints that the identified table should be rendered inside this table row."
        ),
    ] = None
    template: Template | None = None
    field_i18n: Annotated[FieldI18n4 | None, Field(alias="_i18n")] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description="`null` represents an unrollable row, included only for rendering purposes."
        ),
    ]
    tags: Tags | None = None
    field_id: Annotated[AnyOracleRollableRowId, Field(alias="_id")]
=======
        str,
        Field(
            description='The primary text content of this row.', title='MarkdownString'
        ),
    ]
    icon: Annotated[
        str | None,
        Field(
            description='A relative (local) URL pointing to a vector image in the SVG format.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description='Further oracle rolls prompted by this table row.'),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    embed_table: Annotated[
        str | None,
        Field(
            description='Hints that the identified table should be rendered inside this table row.'
        ),
    ] = None
    template: Template | None = None
    i18n: Annotated[I18n4 | None, Field(alias='_i18n')] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description='`null` represents an unrollable row, included only for rendering purposes.'
        ),
    ]
    tags: Tags | None = None
    id: Annotated[
        OracleRollableRowId
        | AssetAbilityOracleRollableRowId
        | MoveOracleRollableRowId
        | TruthOptionOracleRollableRowId,
        Field(alias='_id', title='AnyOracleRollableRowId'),
    ]
>>>>>>> upstream/main


class OracleRollableRowText2(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="The primary text content of this row.")
    ]
    icon: SvgImageUrl | None = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description="Further oracle rolls prompted by this table row."),
    ] = None
    suggestions: Suggestions | None = None
    embed_table: Annotated[
        str | None,
        Field(
            description="Hints that the identified table should be rendered inside this table row."
        ),
    ] = None
    template: Template | None = None
    field_i18n: Annotated[FieldI18n5 | None, Field(alias="_i18n")] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description="`null` represents an unrollable row, included only for rendering purposes."
        ),
    ]
    tags: Tags | None = None
    field_id: Annotated[AnyOracleRollableRowId, Field(alias="_id")]
    text2: Annotated[
        MarkdownString | None,
        Field(
            description="The secondary text for this row. Use `null` to represent a cell with a blank or empty vlue."
=======
        str,
        Field(
            description='The primary text content of this row.', title='MarkdownString'
        ),
    ]
    icon: Annotated[
        str | None,
        Field(
            description='A relative (local) URL pointing to a vector image in the SVG format.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description='Further oracle rolls prompted by this table row.'),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    embed_table: Annotated[
        str | None,
        Field(
            description='Hints that the identified table should be rendered inside this table row.'
        ),
    ] = None
    template: Template | None = None
    i18n: Annotated[I18n5 | None, Field(alias='_i18n')] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description='`null` represents an unrollable row, included only for rendering purposes.'
        ),
    ]
    tags: Tags | None = None
    id: Annotated[
        OracleRollableRowId
        | AssetAbilityOracleRollableRowId
        | MoveOracleRollableRowId
        | TruthOptionOracleRollableRowId,
        Field(alias='_id', title='AnyOracleRollableRowId'),
    ]
    text2: Annotated[
        str | None,
        Field(
            description='The secondary text for this row. Use `null` to represent a cell with a blank or empty vlue.'
>>>>>>> upstream/main
        ),
    ]


class OracleRollableRowText3(BaseModel):
    text: Annotated[
<<<<<<< HEAD
        MarkdownString, Field(description="The primary text content of this row.")
    ]
    icon: SvgImageUrl | None = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description="Further oracle rolls prompted by this table row."),
    ] = None
    suggestions: Suggestions | None = None
    embed_table: Annotated[
        str | None,
        Field(
            description="Hints that the identified table should be rendered inside this table row."
        ),
    ] = None
    template: Template | None = None
    field_i18n: Annotated[FieldI18n6 | None, Field(alias="_i18n")] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description="`null` represents an unrollable row, included only for rendering purposes."
        ),
    ]
    tags: Tags | None = None
    field_id: Annotated[AnyOracleRollableRowId, Field(alias="_id")]
    text2: Annotated[
        MarkdownString | None,
        Field(
            description="The secondary text for this row. Use `null` to represent a cell with a blank or empty value."
        ),
    ]
    text3: Annotated[
        MarkdownString | None,
        Field(
            description="The tertiary text for this row. Use `null` to represent a cell with a blank or empty vlue."
=======
        str,
        Field(
            description='The primary text content of this row.', title='MarkdownString'
        ),
    ]
    icon: Annotated[
        str | None,
        Field(
            description='A relative (local) URL pointing to a vector image in the SVG format.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    oracle_rolls: Annotated[
        list[OracleRoll] | None,
        Field(description='Further oracle rolls prompted by this table row.'),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    embed_table: Annotated[
        str | None,
        Field(
            description='Hints that the identified table should be rendered inside this table row.'
        ),
    ] = None
    template: Template | None = None
    i18n: Annotated[I18n6 | None, Field(alias='_i18n')] = None
    roll: Annotated[
        DiceRange | None,
        Field(
            description='`null` represents an unrollable row, included only for rendering purposes.'
        ),
    ]
    tags: Tags | None = None
    id: Annotated[
        OracleRollableRowId
        | AssetAbilityOracleRollableRowId
        | MoveOracleRollableRowId
        | TruthOptionOracleRollableRowId,
        Field(alias='_id', title='AnyOracleRollableRowId'),
    ]
    text2: Annotated[
        str | None,
        Field(
            description='The secondary text for this row. Use `null` to represent a cell with a blank or empty value.'
        ),
    ]
    text3: Annotated[
        str | None,
        Field(
            description='The tertiary text for this row. Use `null` to represent a cell with a blank or empty vlue.'
>>>>>>> upstream/main
        ),
    ]


class OracleTablesCollection(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        OracleCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='OracleCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
        ),
    ] = None
    contents: dict[str, OracleRollableTable]
    collections: dict[str, OracleCollection]
    type: Literal["oracle_collection"]
    oracle_type: Literal["tables"]


class OracleTableText(BaseModel):
    field_id: Annotated[
        OracleRollableId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
        ),
    ] = None
    contents: dict[str, Annotated[OracleTableText | OracleTableText2 | OracleTableText3, Discriminator('oracle_type')]]
    collections: dict[str, Annotated[OracleTablesCollection | OracleTableSharedRolls | OracleTableSharedText | OracleTableSharedText2 | OracleTableSharedText3, Discriminator('oracle_type')]]
    type: Literal['oracle_collection']
    oracle_type: Literal['tables']


class OracleTableText(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleRollableIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    column_labels: Annotated[ColumnLabels7, Field(title="TextColumnLabels")]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["table_text"]


class OracleTableText2(BaseModel):
    field_id: Annotated[
        OracleRollableId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    column_labels: Annotated[
        ColumnLabels7,
        Field(
            default_factory=lambda: ColumnLabels7.model_validate(
                {'roll': 'Roll', 'text': 'Result'}
            ),
            title='TextColumnLabels',
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['table_text']


class OracleTableText2(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleRollableIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText2],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    column_labels: Annotated[ColumnLabels8, Field(title="Text2ColumnLabels")]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["table_text2"]


class OracleTableText3(BaseModel):
    field_id: Annotated[
        OracleRollableId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    column_labels: Annotated[
        ColumnLabels8,
        Field(
            default_factory=lambda: ColumnLabels8.model_validate(
                {'roll': 'Roll', 'text': 'Result', 'text2': 'Details'}
            ),
            title='Text2ColumnLabels',
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['table_text2']


class OracleTableText3(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleRollableIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText3],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    column_labels: Annotated[ColumnLabels9, Field(title="Text3ColumnLabels")]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["table_text3"]


class Rarity(BaseModel):
    field_id: Annotated[
        RarityId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    column_labels: Annotated[ColumnLabels9, Field(title='Text3ColumnLabels')]
    type: Literal['oracle_rollable']
    oracle_type: Literal['table_text3']


class Rarity(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^rarity:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='RarityId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[RarityIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    asset: Annotated[AssetId, Field(description="The asset augmented by this rarity.")]
    xp_cost: Annotated[
        int,
        Field(
            description="From Ironsworn: Delve, p. 174:\n\n      Some assets will bring a rarity into play more often than others, so the experience point cost for a rarity will vary by the linked asset. These costs are shown in the tables on page 175.\n\n      If you are playing solo, and arent concerned with the relative balance of rarity abilities, you can ignore these variable costs. If so, spend 3 experience points to purchase a rarity.",
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    asset: Annotated[
        str,
        Field(
            description='The asset augmented by this rarity.',
            pattern='^asset:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='AssetId',
        ),
    ]
    description: Annotated[
        str, Field(description='A description of this rarity.', title='MarkdownString')
    ]
    xp_cost: Annotated[
        int,
        Field(
            description='From Ironsworn: Delve, p. 174:\n\n      Some assets will bring a rarity into play more often than others, so the experience point cost for a rarity will vary by the linked asset. These costs are shown in the tables on page 175.\n\n      If you are playing solo, and arent concerned with the relative balance of rarity abilities, you can ignore these variable costs. If so, spend 3 experience points to purchase a rarity.',
>>>>>>> upstream/main
            ge=3,
            le=5,
        ),
    ]
<<<<<<< HEAD
    type: Literal["rarity"]


class SelectEnhancementFieldChoice(BaseModel):
    label: Label
    choice_type: Literal["choice"]
=======
    type: Literal['rarity']


class SelectEnhancementFieldChoice(BaseModel):
    label: Annotated[
        str,
        Field(
            description='A localized, player-facing name or label, formatted as plain text. In some contexts it may be undesirable to render this text, but it should always be exposed to assistive technology (e.g. with `aria-label` in HTML).',
            title='Label',
        ),
    ]
    choice_type: Literal['choice']
>>>>>>> upstream/main
    enhance_asset: AssetEnhancement | None = None
    enhance_moves: list[MoveEnhancement] | None = None


class SelectEnhancementFieldChoiceGroup(BaseModel):
<<<<<<< HEAD
    name: Annotated[Label, Field(description="A label for this option group.")]
    choice_type: Literal["choice_group"]
=======
    name: Annotated[
        str, Field(description='A label for this option group.', title='Label')
    ]
    choice_type: Literal['choice_group']
>>>>>>> upstream/main
    choices: dict[str, SelectEnhancementFieldChoice]


class TriggerActionRoll(BaseModel):
    text: Annotated[
        str,
        Field(
<<<<<<< HEAD
            description="A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions."
=======
            description='A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions.'
>>>>>>> upstream/main
        ),
    ]
    conditions: Annotated[
        list[TriggerActionRollCondition],
<<<<<<< HEAD
        Field(description="Specific conditions that qualify for this trigger."),
=======
        Field(description='Specific conditions that qualify for this trigger.'),
    ]


class TriggerNoRoll(BaseModel):
    text: Annotated[
        str,
        Field(
            description='A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions.'
        ),
    ]
    conditions: Annotated[
        list[TriggerNoRollCondition],
        Field(
            default_factory=list,
            description='Specific conditions that qualify for this trigger.',
        ),
    ]


class TriggerProgressRoll(BaseModel):
    text: Annotated[
        str,
        Field(
            description='A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions.'
        ),
    ]
    conditions: Annotated[
        list[TriggerProgressRollCondition],
        Field(description='Specific conditions that qualify for this trigger.'),
>>>>>>> upstream/main
    ]


class TriggerSpecialTrack(BaseModel):
    text: Annotated[
        str,
        Field(
<<<<<<< HEAD
            description="A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions."
=======
            description='A markdown string containing the primary trigger text for this move.\n\nSecondary trigger text (for specific stats or uses of an asset ability) may be described in individual trigger conditions.'
>>>>>>> upstream/main
        ),
    ]
    conditions: Annotated[
        list[TriggerSpecialTrackCondition],
<<<<<<< HEAD
        Field(description="Specific conditions that qualify for this trigger."),
=======
        Field(description='Specific conditions that qualify for this trigger.'),
>>>>>>> upstream/main
    ]


class Truth(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        TruthId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^truth:([a-z][a-z0-9_]*\\/[a-z][a-z0-9_]*)$',
            title='TruthId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[TruthIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    dice: DiceExpression
    options: list[TruthOption]
    your_character: MarkdownString | None = None
    factions: Annotated[
        list[EntityPrompt] | None,
        Field(
            description="Prompts for factions related to this truth, like those presented in standard isles. This is presented as a single paragraph in the original text; Datasworn uses an array (one faction prompt per string) to represent them in order to make them more suitable for programmatic use.\n\nThis property is a placeholder and may see signficant changes in v0.2.0."
        ),
    ] = None
    type: Literal["truth"]


class AssetAbility(BaseModel):
    field_id: Annotated[
        AssetAbilityId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[
        Label | None,
        Field(
            description="A handful of asset abilities have a label/name, for instance classic Ironsworn companion assets. Most canonical assets omit this property."
        ),
    ] = None
    text: Annotated[
        MarkdownString,
        Field(description="The complete rules text of this asset ability."),
    ]
    enabled: Annotated[bool, Field(description="Is this asset ability enabled?")]
    moves: Annotated[
        dict[str, EmbeddedMove] | None,
        Field(
            description="Unique moves added by this asset ability.",
            title="AssetAbilityMoves",
        ),
    ] = {}
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title="AssetAbilityOracles")
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    dice: Annotated[
        str,
        Field(
            description='A simple dice roll expression with an optional (positive or negative) modifer.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
    ]
    options: list[TruthOption]
    your_character: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    factions: Annotated[
        list[EntityPrompt] | None,
        Field(
            description='Prompts for factions related to this truth, like those presented in standard isles. This is presented as a single paragraph in the original text; Datasworn uses an array (one faction prompt per string) to represent them in order to make them more suitable for programmatic use.\n\nThis property is a placeholder and may see signficant changes in v0.2.0.'
        ),
    ] = None
    type: Literal['truth']


class AssetAbility(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^asset\\.ability:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)$',
            title='AssetAbilityId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description='A handful of asset abilities have a label/name, for instance classic Ironsworn companion assets. Most canonical assets omit this property.',
            title='Label',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of this asset ability.',
            title='MarkdownString',
        ),
    ]
    enabled: Annotated[bool, Field(description='Is this asset ability enabled?')]
    moves: Annotated[
        dict[str, EmbeddedMove] | None,
        Field(
            description='Unique moves added by this asset ability.',
            title='AssetAbilityMoves',
        ),
    ] = {}
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title='AssetAbilityOracles')
>>>>>>> upstream/main
    ] = {}
    options: Annotated[
        dict[str, AssetAbilityOptionField] | None,
        Field(
<<<<<<< HEAD
            description="Fields that are expected to be set once and remain the same through the life of the asset."
=======
            description='Fields that are expected to be set once and remain the same through the life of the asset.'
>>>>>>> upstream/main
        ),
    ] = {}
    controls: Annotated[
        dict[str, AssetAbilityControlField] | None,
        Field(
<<<<<<< HEAD
            description="Fields whose values are expected to change over the life of the asset."
=======
            description='Fields whose values are expected to change over the life of the asset.'
>>>>>>> upstream/main
        ),
    ] = {}
    enhance_asset: Annotated[
        AssetEnhancement | None,
<<<<<<< HEAD
        Field(description="Changes made to the asset, when this ability is enabled."),
=======
        Field(description='Changes made to the asset, when this ability is enabled.'),
>>>>>>> upstream/main
    ] = None
    enhance_moves: Annotated[
        list[MoveEnhancement] | None,
        Field(
<<<<<<< HEAD
            description="Describes changes made to various moves by this asset ability. Usually these require specific trigger conditions."
=======
            description='Describes changes made to various moves by this asset ability. Usually these require specific trigger conditions.'
>>>>>>> upstream/main
        ),
    ] = None
    tags: Tags | None = None


class AtlasCollection(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        AtlasCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^atlas_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='AtlasCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[AtlasCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[AtlasCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    contents: dict[str, AtlasEntry]
    collections: dict[str, AtlasCollection]
<<<<<<< HEAD
    type: Literal["atlas_collection"]


class EmbeddedActionRollMove(BaseModel):
    field_id: Annotated[EmbeddedMoveId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    trigger: Annotated[
        TriggerActionRoll,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        bool, Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[MoveOutcomes, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["action_roll"]


class EmbeddedOracleColumnText(BaseModel):
    field_id: Annotated[EmbeddedOracleRollableId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
    type: Literal['atlas_collection']


class EmbeddedActionRollMove(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing an AssetAbilityMove object.',
            pattern='^asset\\.ability\\.move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$',
            title='EmbeddedMoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    trigger: Annotated[
        TriggerActionRoll,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        bool, Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[MoveOutcomes, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['action_roll']


class EmbeddedNoRollMove(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing an AssetAbilityMove object.',
            pattern='^asset\\.ability\\.move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$',
            title='EmbeddedMoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    trigger: Annotated[
        TriggerNoRoll,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[None, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['no_roll']


class EmbeddedOracleColumnText(BaseModel):
    id: Annotated[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
        Field(alias='_id', title='EmbeddedOracleRollableId'),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["column_text"]


class EmbeddedOracleColumnText2(BaseModel):
    field_id: Annotated[EmbeddedOracleRollableId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['column_text']


class EmbeddedOracleColumnText2(BaseModel):
    id: Annotated[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
        Field(alias='_id', title='EmbeddedOracleRollableId'),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText2],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["column_text2"]


class EmbeddedOracleColumnText3(BaseModel):
    field_id: Annotated[EmbeddedOracleRollableId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['column_text2']


class EmbeddedOracleColumnText3(BaseModel):
    id: Annotated[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
        Field(alias='_id', title='EmbeddedOracleRollableId'),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText3],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["column_text3"]


class EmbeddedOracleTableText(BaseModel):
    field_id: Annotated[EmbeddedOracleRollableId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['column_text3']


class EmbeddedOracleTableText(BaseModel):
    id: Annotated[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
        Field(alias='_id', title='EmbeddedOracleRollableId'),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    column_labels: Annotated[ColumnLabels, Field(title="TextColumnLabels")]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["table_text"]


class EmbeddedOracleTableText2(BaseModel):
    field_id: Annotated[EmbeddedOracleRollableId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    column_labels: Annotated[
        ColumnLabels,
        Field(
            default_factory=lambda: ColumnLabels.model_validate(
                {'roll': 'Roll', 'text': 'Result'}
            ),
            title='TextColumnLabels',
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['table_text']


class EmbeddedOracleTableText2(BaseModel):
    id: Annotated[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
        Field(alias='_id', title='EmbeddedOracleRollableId'),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText2],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    column_labels: Annotated[ColumnLabels1, Field(title="Text2ColumnLabels")]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["table_text2"]


class EmbeddedOracleTableText3(BaseModel):
    field_id: Annotated[EmbeddedOracleRollableId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    column_labels: Annotated[
        ColumnLabels1,
        Field(
            default_factory=lambda: ColumnLabels1.model_validate(
                {'roll': 'Roll', 'text': 'Result', 'text2': 'Details'}
            ),
            title='Text2ColumnLabels',
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['table_text2']


class EmbeddedOracleTableText3(BaseModel):
    id: Annotated[
        AssetAbilityOracleRollableId
        | TruthOptionOracleRollableId
        | MoveOracleRollableId,
        Field(alias='_id', title='EmbeddedOracleRollableId'),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText3],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    column_labels: Annotated[ColumnLabels2, Field(title="Text3ColumnLabels")]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["table_text3"]


class EmbeddedProgressRollMove(BaseModel):
    field_id: Annotated[EmbeddedMoveId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    trigger: Annotated[
        TriggerProgressRoll,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[MoveOutcomes, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["progress_roll"]
    tracks: Annotated[
        ProgressTrackTypeInfo,
        Field(
            description="Describes the common features of progress tracks associated with this move."
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    column_labels: Annotated[ColumnLabels2, Field(title='Text3ColumnLabels')]
    type: Literal['oracle_rollable']
    oracle_type: Literal['table_text3']


class EmbeddedProgressRollMove(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing an AssetAbilityMove object.',
            pattern='^asset\\.ability\\.move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$',
            title='EmbeddedMoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    trigger: Annotated[
        TriggerProgressRoll,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[MoveOutcomes, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['progress_roll']
    tracks: Annotated[
        ProgressTrackTypeInfo,
        Field(
            description='Describes the common features of progress tracks associated with this move.'
>>>>>>> upstream/main
        ),
    ]


class EmbeddedSpecialTrackMove(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[EmbeddedMoveId, Field(alias="_id")]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
    tags: Tags | None = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    trigger: Annotated[
        TriggerSpecialTrack,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[MoveOutcomes, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["special_track"]


class MoveActionRoll(BaseModel):
    field_id: Annotated[
        MoveId, Field(alias="_id", description="The unique Datasworn ID for this node.")
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='A unique ID representing an AssetAbilityMove object.',
            pattern='^asset\\.ability\\.move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})\\.(\\d+)\\.([a-z][a-z0-9_]*|\\*)$',
            title='EmbeddedMoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    trigger: Annotated[
        TriggerSpecialTrack,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[MoveOutcomes, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['special_track']


class MoveActionRoll(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='MoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[MoveIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title="MoveOracles")
    ] = {}
    trigger: Annotated[
        TriggerActionRoll,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        bool, Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[MoveOutcomes, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["action_roll"]


class MoveSpecialTrack(BaseModel):
    field_id: Annotated[
        MoveId, Field(alias="_id", description="The unique Datasworn ID for this node.")
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
            description='Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title='MoveOracles')
    ] = {}
    trigger: Annotated[
        TriggerActionRoll,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        bool, Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[MoveOutcomes, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['action_roll']


class MoveNoRoll(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='MoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[MoveIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    text: Annotated[
        MarkdownString, Field(description="The complete rules text of the move.")
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title="MoveOracles")
    ] = {}
    trigger: Annotated[
        TriggerSpecialTrack,
        Field(description="Trigger conditions for this move.", title="Trigger"),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description="Is burning momentum allowed for this move?")
    ]
    outcomes: Annotated[MoveOutcomes, Field(title="MoveOutcomes")]
    type: Literal["move"]
    roll_type: Literal["special_track"]


class OracleColumnText(BaseModel):
    field_id: Annotated[
        OracleRollableId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
=======
            description='Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title='MoveOracles')
    ] = {}
    trigger: Annotated[
        TriggerNoRoll,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[None, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['no_roll']


class MoveProgressRoll(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='MoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    replaces: Annotated[
        list[MoveIdWildcard] | None,
        Field(
            description='Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title='MoveOracles')
    ] = {}
    trigger: Annotated[
        TriggerProgressRoll,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[MoveOutcomes, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['progress_roll']
    tracks: Annotated[
        ProgressTrackTypeInfo,
        Field(
            description='Describes the common features of progress tracks associated with this move.'
        ),
    ]


class MoveSpecialTrack(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^move:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='MoveId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
    tags: Tags | None = None
    replaces: Annotated[
        list[MoveIdWildcard] | None,
        Field(
            description='Indicates that this move replaces the identified moves. References to the replaced moves can be considered equivalent to this move.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description='The complete rules text of the move.', title='MarkdownString'
        ),
    ]
    oracles: Annotated[
        dict[str, EmbeddedOracleRollable] | None, Field(title='MoveOracles')
    ] = {}
    trigger: Annotated[
        TriggerSpecialTrack,
        Field(description='Trigger conditions for this move.', title='Trigger'),
    ]
    allow_momentum_burn: Annotated[
        Literal[False], Field(description='Is burning momentum allowed for this move?')
    ]
    outcomes: Annotated[MoveOutcomes, Field(title='MoveOutcomes')]
    type: Literal['move']
    roll_type: Literal['special_track']


class OracleColumnText(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleRollableIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["column_text"]


class OracleColumnText2(BaseModel):
    field_id: Annotated[
        OracleRollableId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['column_text']


class OracleColumnText2(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleRollableIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText2],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["column_text2"]


class OracleColumnText3(BaseModel):
    field_id: Annotated[
        OracleRollableId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    suggestions: Suggestions | None = None
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['column_text2']


class OracleColumnText3(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_rollable:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='OracleRollableId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleRollableIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        DiceExpression,
        Field(description="The roll used to select a result on this oracle."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    recommended_rolls: RecommendedRolls | None = None
    dice: Annotated[
        str,
        Field(
            description='The roll used to select a result on this oracle.',
            examples=['1d100', '1d6+2', '2d10'],
            pattern='([1-9][0-9]*)d([1-9][0-9]*)([+-]([1-9][0-9]*))?',
            title='DiceExpression',
        ),
>>>>>>> upstream/main
    ]
    match: Annotated[
        OracleMatchBehavior | None,
        Field(
<<<<<<< HEAD
            description="Most oracle tables are insensitive to matches, but a few define special match behavior."
=======
            description='Most oracle tables are insensitive to matches, but a few define special match behavior.'
>>>>>>> upstream/main
        ),
    ] = None
    rows: Annotated[
        list[OracleRollableRowText3],
        Field(
<<<<<<< HEAD
            description="An array of objects, each representing a single row of the table."
        ),
    ]
    type: Literal["oracle_rollable"]
    oracle_type: Literal["column_text3"]
=======
            description='An array of objects, each representing a single row of the table.'
        ),
    ]
    type: Literal['oracle_rollable']
    oracle_type: Literal['column_text3']
>>>>>>> upstream/main


class OracleRollableRow(
    RootModel[OracleRollableRowText | OracleRollableRowText2 | OracleRollableRowText3]
):
    root: Annotated[
        OracleRollableRowText | OracleRollableRowText2 | OracleRollableRowText3,
<<<<<<< HEAD
        Field(title="OracleRollableRow"),
=======
        Field(title='OracleRollableRow'),
>>>>>>> upstream/main
    ]


class OracleTableSharedRolls(BaseModel):
<<<<<<< HEAD
    field_id: Annotated[
        OracleCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='OracleCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    contents: dict[str, OracleColumnText]
    column_labels: Annotated[
        ColumnLabels3,
        Field(
<<<<<<< HEAD
            description="Provides column labels for this table. The `roll` key refers to the roll column showing the dice range (`min` and `max` on each table row). For all other column labels, see the `name` property of each child `OracleColumn`.",
            title="SharedRollsLabels",
        ),
    ]
    type: Literal["oracle_collection"]
    oracle_type: Literal["table_shared_rolls"]


class OracleTableSharedText(BaseModel):
    field_id: Annotated[
        OracleCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
            default_factory=lambda: ColumnLabels3.model_validate({'roll': 'Roll'}),
            description='Provides column labels for this table. The `roll` key refers to the roll column showing the dice range (`min` and `max` on each table row). For all other column labels, see the `name` property of each child `OracleColumn`.',
            title='SharedRollsLabels',
        ),
    ]
    type: Literal['oracle_collection']
    oracle_type: Literal['table_shared_rolls']


class OracleTableSharedText(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='OracleCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
        ),
    ] = None
    contents: dict[str, OracleColumnText]
    column_labels: Annotated[ColumnLabels4, Field(title="SharedTextLabels")]
    type: Literal["oracle_collection"]
    oracle_type: Literal["table_shared_text"]


class OracleTableSharedText2(BaseModel):
    field_id: Annotated[
        OracleCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
        ),
    ] = None
    contents: dict[str, OracleColumnText]
    column_labels: Annotated[
        ColumnLabels4,
        Field(
            default_factory=lambda: ColumnLabels4.model_validate({'text': 'Result'}),
            title='SharedTextLabels',
        ),
    ]
    type: Literal['oracle_collection']
    oracle_type: Literal['table_shared_text']


class OracleTableSharedText2(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='OracleCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
        ),
    ] = None
    contents: dict[str, OracleColumnText2]
    column_labels: Annotated[ColumnLabels5, Field(title="SharedText2Labels")]
    type: Literal["oracle_collection"]
    oracle_type: Literal["table_shared_text2"]


class OracleTableSharedText3(BaseModel):
    field_id: Annotated[
        OracleCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
        ),
    ] = None
    contents: dict[str, OracleColumnText2]
    column_labels: Annotated[
        ColumnLabels5,
        Field(
            default_factory=lambda: ColumnLabels5.model_validate(
                {'text': 'Result', 'text2': 'Details'}
            ),
            title='SharedText2Labels',
        ),
    ]
    type: Literal['oracle_collection']
    oracle_type: Literal['table_shared_text2']


class OracleTableSharedText3(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^oracle_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='OracleCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[OracleCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
        ),
    ] = None
    contents: dict[str, OracleColumnText3]
    column_labels: Annotated[ColumnLabels6, Field(title="SharedText3Labels")]
    type: Literal["oracle_collection"]
    oracle_type: Literal["table_shared_text3"]


class Asset(BaseModel):
    field_id: Annotated[
        AssetId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
        ),
    ] = None
    contents: dict[str, OracleColumnText3]
    column_labels: Annotated[
        ColumnLabels6,
        Field(
            default_factory=lambda: ColumnLabels6.model_validate({}),
            title='SharedText3Labels',
        ),
    ]
    type: Literal['oracle_collection']
    oracle_type: Literal['table_shared_text3']


class Asset(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^asset:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){2,5})$',
            title='AssetId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[AssetIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
    ] = None
    category: Annotated[
        Label,
        Field(
            description="A localized category label for this asset. This is the surtitle above the asset's name on the card.",
            examples=[
                "Combat Talent",
                "Command Vehicle",
                "Companion",
                "Deed",
                "Module",
                "Path",
                "Ritual",
                "Support Vehicle",
            ],
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
    ] = None
    category: Annotated[
        str,
        Field(
            description="A localized category label for this asset. This is the surtitle above the asset's name on the card.",
            examples=[
                'Combat Talent',
                'Command Vehicle',
                'Companion',
                'Deed',
                'Module',
                'Path',
                'Ritual',
                'Support Vehicle',
            ],
            title='Label',
>>>>>>> upstream/main
        ),
    ]
    options: Annotated[
        dict[str, AssetOptionField],
        Field(
            description="Options are input fields set when the player purchases the asset. They're likely to remain the same through the life of the asset. Typically, they are rendered at the top of the asset card."
        ),
    ]
    requirement: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description="Describes prerequisites for purchasing or using this asset."
=======
        str | None,
        Field(
            description='Describes prerequisites for purchasing or using this asset.',
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    abilities: list[AssetAbility]
    controls: Annotated[
        dict[str, AssetControlField] | None,
        Field(
<<<<<<< HEAD
            description="Controls are condition meters, clocks, counters, and other asset input fields whose values are expected to change throughout the life of the asset."
=======
            description='Controls are condition meters, clocks, counters, and other asset input fields whose values are expected to change throughout the life of the asset.'
>>>>>>> upstream/main
        ),
    ] = {}
    count_as_impact: Annotated[
        bool,
        Field(
<<<<<<< HEAD
            description="If `true`, this asset counts as an impact (Starforged) or a debility (classic Ironsworn)."
=======
            description='If `true`, this asset counts as an impact (Starforged) or a debility (classic Ironsworn).'
>>>>>>> upstream/main
        ),
    ]
    attachments: AssetAttachment | None = None
    shared: Annotated[
        bool,
        Field(
            description="Most assets only benefit to their owner, but certain assets (like Starforged's module and command vehicle assets) are shared amongst the player's allies, too."
        ),
    ]
<<<<<<< HEAD
    type: Literal["asset"]


class AssetCollection(BaseModel):
    field_id: Annotated[
        AssetCollectionId,
        Field(alias="_id", description="The unique Datasworn ID for this node."),
    ]
    field_comment: Annotated[Documentation | None, Field(alias="_comment")] = None
    name: Annotated[Label, Field(description="The primary name/label for this node.")]
    canonical_name: Annotated[
        Label | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`."
        ),
    ] = None
    field_source: Annotated[
        SourceInfo,
        Field(
            alias="_source",
            description="Attribution for the original source (such as a book or website) of this node, including the author and licensing information.",
        ),
    ]
    suggestions: Suggestions | None = None
=======
    type: Literal['asset']


class AssetCollection(BaseModel):
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The unique Datasworn ID for this node.',
            pattern='^asset_collection:([a-z][a-z0-9_]*(?:\\/[a-z][a-z0-9_]*){1,4})$',
            title='AssetCollectionId',
        ),
    ]
    comment: Annotated[
        str | None,
        Field(
            alias='_comment',
            description='Implementation hints or other developer-facing comments on this node. These should be omitted when representing an object for gameplay.',
            title='Documentation',
        ),
    ] = None
    name: Annotated[
        str, Field(description='The primary name/label for this node.', title='Label')
    ]
    canonical_name: Annotated[
        str | None,
        Field(
            description="The name of this node as it appears on the page in the book, if it's different from `name`.",
            title='Label',
        ),
    ] = None
    source: Annotated[
        SourceInfo,
        Field(
            alias='_source',
            description='Attribution for the original source (such as a book or website) of this node, including the author and licensing information.',
        ),
    ]
    suggestions: Annotated[
        list[
            AtlasEntryIdWildcard
            | NpcIdWildcard
            | NpcVariantIdWildcard
            | OracleRollableIdWildcard
            | AssetAbilityOracleRollableIdWildcard
            | MoveOracleRollableIdWildcard
            | TruthOptionOracleRollableIdWildcard
            | OracleRollableRowIdWildcard
            | AssetAbilityOracleRollableRowIdWildcard
            | MoveOracleRollableRowIdWildcard
            | TruthOptionOracleRollableRowIdWildcard
            | AssetIdWildcard
            | AssetAbilityIdWildcard
            | AssetAbilityMoveIdWildcard
            | MoveIdWildcard
            | AssetAbilityMoveConditionIdWildcard
            | MoveConditionIdWildcard
            | AssetAbilityMoveOutcomeIdWildcard
            | MoveOutcomeIdWildcard
            | AtlasCollectionIdWildcard
            | NpcCollectionIdWildcard
            | OracleCollectionIdWildcard
            | AssetCollectionIdWildcard
            | MoveCategoryIdWildcard
            | DelveSiteIdWildcard
            | DelveSiteDenizenIdWildcard
            | DelveSiteDomainIdWildcard
            | DelveSiteDomainFeatureIdWildcard
            | DelveSiteThemeFeatureIdWildcard
            | DelveSiteDomainDangerIdWildcard
            | DelveSiteThemeDangerIdWildcard
            | DelveSiteThemeIdWildcard
            | RarityIdWildcard
            | TruthIdWildcard
            | TruthOptionIdWildcard
        ]
        | None,
        Field(title='Suggestions'),
    ] = None
>>>>>>> upstream/main
    tags: Tags | None = None
    replaces: Annotated[
        list[AssetCollectionIdWildcard] | None,
        Field(
<<<<<<< HEAD
            description="This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node."
        ),
    ] = None
    color: Annotated[
        CssColor | None,
        Field(description="A thematic color associated with this node."),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        SvgImageUrl | None,
        Field(description="An SVG icon associated with this collection."),
=======
            description='This node replaces all nodes that match these wildcards. References to the replaced nodes can be considered equivalent to this node.'
        ),
    ] = None
    color: Annotated[
        str | None,
        Field(
            description='A thematic color associated with this node.', title='CssColor'
        ),
    ] = None
    images: list[WebpImageUrl] | None = None
    icon: Annotated[
        str | None,
        Field(
            description='An SVG icon associated with this collection.',
            pattern='\\.svg$',
            title='SvgImageUrl',
        ),
>>>>>>> upstream/main
    ] = None
    enhances: Annotated[
        list[AssetCollectionIdWildcard] | None,
        Field(
            description="This node's content enhances all nodes that match these wildcards, rather than being a standalone item of its own."
        ),
    ] = None
    summary: Annotated[
<<<<<<< HEAD
        MarkdownString | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.'
        ),
    ] = None
    description: Annotated[
        MarkdownString | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead."
=======
        str | None,
        Field(
            description='A brief summary of this collection, no more than a few sentences in length. This is intended for use in application tooltips and similar sorts of hints. Longer text should use the "description" key instead.',
            title='MarkdownString',
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="A longer description of this collection, which might include multiple paragraphs. If it's only a couple sentences, use the `summary` key instead.",
            title='MarkdownString',
>>>>>>> upstream/main
        ),
    ] = None
    contents: dict[str, Asset]
    collections: dict[str, AssetCollection]
<<<<<<< HEAD
    type: Literal["asset_collection"]
=======
    type: Literal['asset_collection']
>>>>>>> upstream/main


class Expansion(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    field_id: Annotated[ExpansionId, Field(alias="_id")]
    type: Literal["expansion"]
    datasworn_version: Annotated[
        Literal["0.1.0"],
        Field(
            description="The version of the Datasworn format used by this data.",
            pattern="^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$",
        ),
    ]
    description: MarkdownString | None = None
    title: Annotated[
        Label,
        Field(
            description="The title of the source document.",
            examples=[
                "Ironsworn Rulebook",
                "Ironsworn Assets Master Set",
                "Ironsworn: Delve",
                "Ironsworn: Starforged Rulebook",
                "Ironsworn: Starforged Assets",
                "Sundered Isles",
            ],
=======
        extra='allow',
    )
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The ID of a Datasworn package that relies on an external package to provide its ruleset.',
            examples=['delve', 'sundered_isles'],
            pattern='^[a-z][a-z0-9_]*$',
            title='ExpansionId',
        ),
    ]
    type: Literal['expansion']
    datasworn_version: Annotated[
        Literal['0.1.0'],
        Field(
            description='The version of the Datasworn format used by this data.',
            pattern='^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$',
        ),
    ]
    description: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    title: Annotated[
        str,
        Field(
            description='The title of the source document.',
            examples=[
                'Ironsworn Rulebook',
                'Ironsworn Assets Master Set',
                'Ironsworn: Delve',
                'Ironsworn: Starforged Rulebook',
                'Ironsworn: Starforged Assets',
                'Sundered Isles',
            ],
            title='Label',
>>>>>>> upstream/main
        ),
    ]
    authors: Annotated[
        list[AuthorInfo],
        Field(
<<<<<<< HEAD
            description="Lists authors credited by the source material.", min_length=1
=======
            description='Lists authors credited by the source material.', min_length=1
>>>>>>> upstream/main
        ),
    ]
    date: Annotated[
        date_aliased,
        Field(
            description="The date of the source documents's last update, formatted YYYY-MM-DD. Required because it's used to determine whether the data needs updating.",
<<<<<<< HEAD
            # pattern="[0-9]{4}-((0[0-9])|(1[0-2]))-(([0-2][0-9])|(3[0-1]))",
        ),
    ]
    url: Annotated[
        WebUrl,
        Field(
            description="A URL where the source document is available.",
            examples=["https://ironswornrpg.com"],
        ),
    ]
    license: Annotated[
        WebUrl | None,
        Field(
            description="An URL pointing to the location where this content's license can be found.\n\nA `null` here indicates that the content provides __no__ license, and is not intended for redistribution.",
            examples=[
                "https://creativecommons.org/licenses/by/4.0",
                "https://creativecommons.org/licenses/by-nc-sa/4.0",
=======
        ),
    ]
    url: Annotated[
        AnyUrl,
        Field(
            description='A URL where the source document is available.',
            examples=['https://ironswornrpg.com'],
            title='WebUrl',
        ),
    ]
    license: Annotated[
        AnyUrl | None,
        Field(
            description="An URL pointing to the location where this content's license can be found.\n\nA `null` here indicates that the content provides __no__ license, and is not intended for redistribution.",
            examples=[
                'https://creativecommons.org/licenses/by/4.0',
                'https://creativecommons.org/licenses/by-nc-sa/4.0',
>>>>>>> upstream/main
            ],
        ),
    ]
    oracles: Annotated[
        dict[str, OracleTablesCollection],
        Field(
<<<<<<< HEAD
            description="A dictionary object containing oracle collections, which may contain oracle tables and/or oracle collections."
=======
            description='A dictionary object containing oracle collections, which may contain oracle tables and/or oracle collections.'
>>>>>>> upstream/main
        ),
    ]
    moves: Annotated[
        dict[str, MoveCategory],
        Field(
<<<<<<< HEAD
            description="A dictionary object containing move categories, which contain moves."
=======
            description='A dictionary object containing move categories, which contain moves.'
>>>>>>> upstream/main
        ),
    ]
    assets: Annotated[
        dict[str, AssetCollection],
        Field(
<<<<<<< HEAD
            description="A dictionary object containing asset collections, which contain assets."
=======
            description='A dictionary object containing asset collections, which contain assets.'
>>>>>>> upstream/main
        ),
    ]
    atlas: Annotated[
        dict[str, AtlasCollection] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object containing atlas collections, which contain atlas entries."
=======
            description='A dictionary object containing atlas collections, which contain atlas entries.'
>>>>>>> upstream/main
        ),
    ] = {}
    npcs: Annotated[
        dict[str, NpcCollection] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object containing NPC collections, which contain NPCs."
=======
            description='A dictionary object containing NPC collections, which contain NPCs.'
>>>>>>> upstream/main
        ),
    ] = {}
    truths: Annotated[
        dict[str, Truth] | None,
<<<<<<< HEAD
        Field(description="A dictionary object of truth categories."),
=======
        Field(description='A dictionary object of truth categories.'),
>>>>>>> upstream/main
    ] = {}
    rarities: Annotated[
        dict[str, Rarity] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object containing rarities, like those presented in Ironsworn: Delve."
=======
            description='A dictionary object containing rarities, like those presented in Ironsworn: Delve.'
>>>>>>> upstream/main
        ),
    ] = {}
    delve_sites: Annotated[
        dict[str, DelveSite] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object of delve sites, like the premade delve sites presented in Ironsworn: Delve"
=======
            description='A dictionary object of delve sites, like the premade delve sites presented in Ironsworn: Delve'
>>>>>>> upstream/main
        ),
    ] = {}
    site_themes: Annotated[
        dict[str, DelveSiteTheme] | None,
<<<<<<< HEAD
        Field(description="A dictionary object containing delve site themes."),
    ] = {}
    site_domains: Annotated[
        dict[str, DelveSiteDomain] | None,
        Field(description="A dictionary object containing delve site domains."),
    ] = {}
    ruleset: RulesetId
=======
        Field(description='A dictionary object containing delve site themes.'),
    ] = {}
    site_domains: Annotated[
        dict[str, DelveSiteDomain] | None,
        Field(description='A dictionary object containing delve site domains.'),
    ] = {}
    ruleset: Annotated[
        str,
        Field(
            description='The ID of standalone Datasworn package that describes its own ruleset.',
            examples=['classic', 'starforged'],
            pattern='^[a-z][a-z0-9_]*$',
            title='RulesetId',
        ),
    ]
>>>>>>> upstream/main
    rules: RulesExpansion | None = None


class Rules(BaseModel):
    stats: Annotated[
        dict[str, StatRule],
        Field(
<<<<<<< HEAD
            description="Describes the standard stats used by player characters in this ruleset."
=======
            description='Describes the standard stats used by player characters in this ruleset.'
>>>>>>> upstream/main
        ),
    ]
    condition_meters: Annotated[
        dict[str, ConditionMeterRule],
        Field(
<<<<<<< HEAD
            description="Describes the standard condition meters used by player characters in this ruleset."
=======
            description='Describes the standard condition meters used by player characters in this ruleset.'
>>>>>>> upstream/main
        ),
    ]
    impacts: Annotated[
        dict[str, ImpactCategory],
        Field(
<<<<<<< HEAD
            description="Describes the standard impacts/debilities used by player characters in this ruleset."
=======
            description='Describes the standard impacts/debilities used by player characters in this ruleset.'
>>>>>>> upstream/main
        ),
    ]
    special_tracks: Annotated[
        dict[str, SpecialTrackRule],
        Field(
<<<<<<< HEAD
            description="Describes the special tracks used by player characters in this ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged)."
=======
            description='Describes the special tracks used by player characters in this ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).'
>>>>>>> upstream/main
        ),
    ]
    tags: dict[str, TagRule]


class Ruleset(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    field_id: Annotated[RulesetId, Field(alias="_id")]
    type: Literal["ruleset"]
    datasworn_version: Annotated[
        Literal["0.1.0"],
        Field(
            description="The version of the Datasworn format used by this data.",
            pattern="^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$",
        ),
    ]
    description: MarkdownString | None = None
    title: Annotated[
        Label,
        Field(
            description="The title of the source document.",
            examples=[
                "Ironsworn Rulebook",
                "Ironsworn Assets Master Set",
                "Ironsworn: Delve",
                "Ironsworn: Starforged Rulebook",
                "Ironsworn: Starforged Assets",
                "Sundered Isles",
            ],
=======
        extra='allow',
    )
    id: Annotated[
        str,
        Field(
            alias='_id',
            description='The ID of standalone Datasworn package that describes its own ruleset.',
            examples=['classic', 'starforged'],
            pattern='^[a-z][a-z0-9_]*$',
            title='RulesetId',
        ),
    ]
    type: Literal['ruleset']
    datasworn_version: Annotated[
        Literal['0.1.0'],
        Field(
            description='The version of the Datasworn format used by this data.',
            pattern='^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$',
        ),
    ]
    description: Annotated[
        str | None,
        Field(
            description='Localized, player-facing text, formatted in Markdown. It is *not* formatted for use "out of the box"; it uses some custom syntax, intended to be replaced in whatever way is most appropriate for your implementation.\n\n* `[Link text](datasworn:move:starforged/suffer/pay_the_price)`: A link to the identified object. The ID must conform to the `AnyId` type; no wildcards allowed.\n* `{{table>oracle_rollable:starforged/core/action}}`: the referenced oracle is rendered here in the source material. The ID must conform to the `AnyOracleRollableId` type; no wildcards allowed.\n* `{{table_columns>move:delve/delve/delve_the_depths}}`: Render *all* direct OracleRollable children of the identified node. This can be an OracleCollectionId, or the ID of anything that can have EmbeddedOracleRollables (such as a Move or TruthOption).\n',
            title='MarkdownString',
        ),
    ] = None
    title: Annotated[
        str,
        Field(
            description='The title of the source document.',
            examples=[
                'Ironsworn Rulebook',
                'Ironsworn Assets Master Set',
                'Ironsworn: Delve',
                'Ironsworn: Starforged Rulebook',
                'Ironsworn: Starforged Assets',
                'Sundered Isles',
            ],
            title='Label',
>>>>>>> upstream/main
        ),
    ]
    authors: Annotated[
        list[AuthorInfo],
        Field(
<<<<<<< HEAD
            description="Lists authors credited by the source material.", min_length=1
=======
            description='Lists authors credited by the source material.', min_length=1
>>>>>>> upstream/main
        ),
    ]
    date: Annotated[
        date_aliased,
        Field(
            description="The date of the source documents's last update, formatted YYYY-MM-DD. Required because it's used to determine whether the data needs updating.",
<<<<<<< HEAD
            # pattern="[0-9]{4}-((0[0-9])|(1[0-2]))-(([0-2][0-9])|(3[0-1]))",
        ),
    ]
    url: Annotated[
        WebUrl,
        Field(
            description="A URL where the source document is available.",
            examples=["https://ironswornrpg.com"],
        ),
    ]
    license: Annotated[
        WebUrl | None,
        Field(
            description="An URL pointing to the location where this content's license can be found.\n\nA `null` here indicates that the content provides __no__ license, and is not intended for redistribution.",
            examples=[
                "https://creativecommons.org/licenses/by/4.0",
                "https://creativecommons.org/licenses/by-nc-sa/4.0",
=======
        ),
    ]
    url: Annotated[
        AnyUrl,
        Field(
            description='A URL where the source document is available.',
            examples=['https://ironswornrpg.com'],
            title='WebUrl',
        ),
    ]
    license: Annotated[
        AnyUrl | None,
        Field(
            description="An URL pointing to the location where this content's license can be found.\n\nA `null` here indicates that the content provides __no__ license, and is not intended for redistribution.",
            examples=[
                'https://creativecommons.org/licenses/by/4.0',
                'https://creativecommons.org/licenses/by-nc-sa/4.0',
>>>>>>> upstream/main
            ],
        ),
    ]
    oracles: Annotated[
        dict[str, OracleTablesCollection],
        Field(
<<<<<<< HEAD
            description="A dictionary object containing oracle collections, which may contain oracle tables and/or oracle collections."
=======
            description='A dictionary object containing oracle collections, which may contain oracle tables and/or oracle collections.'
>>>>>>> upstream/main
        ),
    ]
    moves: Annotated[
        dict[str, MoveCategory],
        Field(
<<<<<<< HEAD
            description="A dictionary object containing move categories, which contain moves."
=======
            description='A dictionary object containing move categories, which contain moves.'
>>>>>>> upstream/main
        ),
    ]
    assets: Annotated[
        dict[str, AssetCollection],
        Field(
<<<<<<< HEAD
            description="A dictionary object containing asset collections, which contain assets."
=======
            description='A dictionary object containing asset collections, which contain assets.'
>>>>>>> upstream/main
        ),
    ]
    atlas: Annotated[
        dict[str, AtlasCollection] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object containing atlas collections, which contain atlas entries."
=======
            description='A dictionary object containing atlas collections, which contain atlas entries.'
>>>>>>> upstream/main
        ),
    ] = {}
    npcs: Annotated[
        dict[str, NpcCollection] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object containing NPC collections, which contain NPCs."
=======
            description='A dictionary object containing NPC collections, which contain NPCs.'
>>>>>>> upstream/main
        ),
    ] = {}
    truths: Annotated[
        dict[str, Truth] | None,
<<<<<<< HEAD
        Field(description="A dictionary object of truth categories."),
=======
        Field(description='A dictionary object of truth categories.'),
>>>>>>> upstream/main
    ] = {}
    rarities: Annotated[
        dict[str, Rarity] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object containing rarities, like those presented in Ironsworn: Delve."
=======
            description='A dictionary object containing rarities, like those presented in Ironsworn: Delve.'
>>>>>>> upstream/main
        ),
    ] = {}
    delve_sites: Annotated[
        dict[str, DelveSite] | None,
        Field(
<<<<<<< HEAD
            description="A dictionary object of delve sites, like the premade delve sites presented in Ironsworn: Delve"
=======
            description='A dictionary object of delve sites, like the premade delve sites presented in Ironsworn: Delve'
>>>>>>> upstream/main
        ),
    ] = {}
    site_themes: Annotated[
        dict[str, DelveSiteTheme] | None,
<<<<<<< HEAD
        Field(description="A dictionary object containing delve site themes."),
    ] = {}
    site_domains: Annotated[
        dict[str, DelveSiteDomain] | None,
        Field(description="A dictionary object containing delve site domains."),
=======
        Field(description='A dictionary object containing delve site themes.'),
    ] = {}
    site_domains: Annotated[
        dict[str, DelveSiteDomain] | None,
        Field(description='A dictionary object containing delve site domains.'),
>>>>>>> upstream/main
    ] = {}
    rules: Rules


class RulesExpansion(BaseModel):
    stats: Annotated[
        dict[str, StatRule] | None,
        Field(
<<<<<<< HEAD
            description="Describes the standard stats used by player characters in this ruleset."
=======
            description='Describes the standard stats used by player characters in this ruleset.'
>>>>>>> upstream/main
        ),
    ] = {}
    condition_meters: Annotated[
        dict[str, ConditionMeterRule] | None,
        Field(
<<<<<<< HEAD
            description="Describes the standard condition meters used by player characters in this ruleset."
=======
            description='Describes the standard condition meters used by player characters in this ruleset.'
>>>>>>> upstream/main
        ),
    ] = {}
    impacts: Annotated[
        dict[str, ImpactCategory] | None,
        Field(
<<<<<<< HEAD
            description="Describes the standard impacts/debilities used by player characters in this ruleset."
=======
            description='Describes the standard impacts/debilities used by player characters in this ruleset.'
>>>>>>> upstream/main
        ),
    ] = {}
    special_tracks: Annotated[
        dict[str, SpecialTrackRule] | None,
        Field(
<<<<<<< HEAD
            description="Describes the special tracks used by player characters in this ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged)."
=======
            description='Describes the special tracks used by player characters in this ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).'
>>>>>>> upstream/main
        ),
    ] = {}
    tags: dict[str, TagRule] | None = {}


class TagRule(BaseModel):
    node_types: Annotated[
<<<<<<< HEAD
        list[TaggableNodeType] | None,
        Field(
            description="Types of object that can receive this tag, or `null` if any type of object accepts it."
        ),
    ]
    field_schema: Annotated[
        TagSchema,
        Field(alias="$schema", description="The JSON schema for this tag value."),
=======
        list[
            CollectableType
            | NonCollectableType
            | CollectionType
            | EmbedOnlyType
            | RuleType
        ]
        | None,
        Field(
            description='Types of object that can receive this tag, or `null` if any type of object accepts it.'
        ),
    ]
    schema_: Annotated[
        TagSchema10
        | TagSchema11
        | TagSchema12
        | TagSchema13
        | TagSchema14
        | TagSchema15
        | TagSchema16
        | TagSchema17,
        Field(
            alias='$schema',
            description='The JSON schema for this tag value.',
            examples=[
                {
                    'description': 'An example tag with a simple true/false value.',
                    'type': 'boolean',
                },
                {
                    'description': 'An example tag with an array of oracle rollable ID wildcards.',
                    'type': 'array',
                    'items': {'$ref': '#/definitions/OracleRollableIdWildcard'},
                },
            ],
            title='TagSchema',
        ),
>>>>>>> upstream/main
    ]


class TagSchema7(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    type: Literal["object"]
    properties: dict[str, TagSchema]
=======
        extra='allow',
    )
    type: Literal['object']
    properties: dict[
        str,
        TagSchema10
        | TagSchema11
        | TagSchema12
        | TagSchema13
        | TagSchema14
        | TagSchema15
        | TagSchema16
        | TagSchema17,
    ]
>>>>>>> upstream/main


class TagSchema8(BaseModel):
    model_config = ConfigDict(
<<<<<<< HEAD
        extra="allow",
    )
    type: Literal["array"]
    items: TagSchema


class Schema1(BaseModel):
    field_id: Annotated[str | None, Field(alias="$id")] = None
    field_schema: Annotated[AnyUrl | None, Field(alias="$schema")] = None
    field_ref: Annotated[str | None, Field(alias="$ref")] = None
    field_comment: Annotated[str | None, Field(alias="$comment")] = None
=======
        extra='allow',
    )
    type: Literal['array']
    items: Annotated[
        TagSchema10
        | TagSchema11
        | TagSchema12
        | TagSchema13
        | TagSchema14
        | TagSchema15
        | TagSchema16
        | TagSchema17,
        Field(
            description='JSON schema used to validate the tag data, with a mandatory description. Only a subset of all possible JSON schema are allowed, including references to some Datasworn types.',
            examples=[
                {
                    'description': 'An example tag with a simple true/false value.',
                    'type': 'boolean',
                },
                {
                    'description': 'An example tag with an array of oracle rollable ID wildcards.',
                    'type': 'array',
                    'items': {'$ref': '#/definitions/OracleRollableIdWildcard'},
                },
            ],
            title='TagSchema',
        ),
    ]


class Schema1(BaseModel):
    id: Annotated[str | None, Field(alias='$id')] = None
    schema_: Annotated[AnyUrl | None, Field(alias='$schema')] = None
    ref: Annotated[str | None, Field(alias='$ref')] = None
    comment: Annotated[str | None, Field(alias='$comment')] = None
>>>>>>> upstream/main
    title: str | None = None
    description: str | None = None
    default: Any | None = None
    readOnly: bool | None = False
    writeOnly: bool | None = False
    examples: list[Any] | None = None
    multipleOf: Annotated[float | None, Field(gt=0.0)] = None
    maximum: float | None = None
    exclusiveMaximum: float | None = None
    minimum: float | None = None
    exclusiveMinimum: float | None = None
<<<<<<< HEAD
    maxLength: NonNegativeInteger | None = None
    minLength: NonNegativeIntegerDefault0 | None = None
    pattern: str | None = None
    additionalItems: Annotated[
        Schema | None, Field(default_factory=lambda: Schema(True))
    ]
    items: Annotated[
        Schema | SchemaArray | None, Field(default_factory=lambda: Schema(True))
    ]
    maxItems: NonNegativeInteger | None = None
    minItems: NonNegativeIntegerDefault0 | None = None
    uniqueItems: bool | None = False
    contains: Annotated[Schema | None, Field(default_factory=lambda: Schema(True))]
    maxProperties: NonNegativeInteger | None = None
    minProperties: NonNegativeIntegerDefault0 | None = None
    required: StringArray | None = None
    additionalProperties: Annotated[
        Schema | None, Field(default_factory=lambda: Schema(True))
    ]
    definitions: Annotated[
        dict[str, Schema] | None, Field(default_factory=lambda: Schema({}))
    ]
    properties: Annotated[
        dict[str, Schema] | None, Field(default_factory=lambda: Schema({}))
    ]
    patternProperties: Annotated[
        dict[str, Schema] | None, Field(default_factory=lambda: Schema({}))
    ]
    dependencies: dict[str, Schema | StringArray] | None = None
    propertyNames: Annotated[Schema | None, Field(default_factory=lambda: Schema(True))]
=======
    maxLength: Annotated[int | None, Field(ge=0)] = None
    minLength: NonNegativeIntegerDefault0 | None = None
    pattern: str | None = None
    additionalItems: Annotated[
        Schema1 | bool | None, Field(title='Core schema meta-schema')
    ] = True
    items: Annotated[
        SchemaArray | Schema1 | bool | None,
        Field(default_factory=lambda: SchemaArray(True)),
    ]
    maxItems: Annotated[int | None, Field(ge=0)] = None
    minItems: NonNegativeIntegerDefault0 | None = None
    uniqueItems: bool | None = False
    contains: Annotated[
        Schema1 | bool | None, Field(title='Core schema meta-schema')
    ] = True
    maxProperties: Annotated[int | None, Field(ge=0)] = None
    minProperties: NonNegativeIntegerDefault0 | None = None
    required: list[str] | None = None
    additionalProperties: Annotated[
        Schema1 | bool | None, Field(title='Core schema meta-schema')
    ] = True
    definitions: dict[str, Schema1 | bool] | None = {}
    properties: dict[str, Schema1 | bool] | None = {}
    patternProperties: dict[str, Schema1 | bool] | None = {}
    dependencies: dict[str, StringArray | Schema1 | bool] | None = None
    propertyNames: Annotated[
        Schema1 | bool | None, Field(title='Core schema meta-schema')
    ] = True
>>>>>>> upstream/main
    const: Any | None = None
    enum: Annotated[list[Any] | None, Field(min_length=1)] = None
    type: SimpleTypes | Type1 | None = None
    format: str | None = None
    contentMediaType: str | None = None
    contentEncoding: str | None = None
    if_: Annotated[
<<<<<<< HEAD
        Schema | None, Field(default_factory=lambda: Schema(True), alias="if")
    ]
    then: Annotated[Schema | None, Field(default_factory=lambda: Schema(True))]
    else_: Annotated[
        Schema | None, Field(default_factory=lambda: Schema(True), alias="else")
    ]
    allOf: SchemaArray | None = None
    anyOf: SchemaArray | None = None
    oneOf: SchemaArray | None = None
    not_: Annotated[
        Schema | None, Field(default_factory=lambda: Schema(True), alias="not")
    ]


class Schema(RootModel[Schema1 | bool]):
    root: Annotated[Schema1 | bool, Field(title="Core schema meta-schema")]
=======
        Schema1 | bool | None, Field(alias='if', title='Core schema meta-schema')
    ] = True
    then: Annotated[Schema1 | bool | None, Field(title='Core schema meta-schema')] = (
        True
    )
    else_: Annotated[
        Schema1 | bool | None, Field(alias='else', title='Core schema meta-schema')
    ] = True
    allOf: Annotated[list[Schema1 | bool] | None, Field(min_length=1)] = None
    anyOf: Annotated[list[Schema1 | bool] | None, Field(min_length=1)] = None
    oneOf: Annotated[list[Schema1 | bool] | None, Field(min_length=1)] = None
    not_: Annotated[
        Schema1 | bool | None, Field(alias='not', title='Core schema meta-schema')
    ] = True
>>>>>>> upstream/main


class TagSchema9(BaseModel):
    pass


<<<<<<< HEAD
class SchemaArray(RootModel[list[Schema]]):
    root: Annotated[list[Schema], Field(min_length=1)]
=======
SchemaArray = Annotated[list[Schema1 | bool], Field(min_length=1)]
>>>>>>> upstream/main


class TagSchema10(TagSchema1, TagSchema9):
    pass


class TagSchema11(TagSchema2, TagSchema9):
    pass


class TagSchema12(TagSchema3, TagSchema9):
    pass


class TagSchema13(TagSchema4, TagSchema9):
    pass


class TagSchema14(TagSchema5, TagSchema9):
    pass


class TagSchema15(TagSchema6, TagSchema9):
    pass


class TagSchema16(TagSchema7, TagSchema9):
    pass


class TagSchema17(TagSchema8, TagSchema9):
    pass


<<<<<<< HEAD
class TagSchema(
    RootModel[
        TagSchema10
        | TagSchema11
        | TagSchema12
        | TagSchema13
        | TagSchema14
        | TagSchema15
        | TagSchema16
        | TagSchema17
    ]
):
    root: Annotated[
        TagSchema10
        | TagSchema11
        | TagSchema12
        | TagSchema13
        | TagSchema14
        | TagSchema15
        | TagSchema16
        | TagSchema17,
        Field(
            description="JSON schema used to validate the tag data, with a mandatory description. Only a subset of all possible JSON schema are allowed, including references to some Datasworn types.",
            examples=[
                {
                    "description": "An example tag with a simple true/false value.",
                    "type": "boolean",
                },
                {
                    "description": "An example tag with an array of oracle rollable ID wildcards.",
                    "type": "array",
                    "items": {"$ref": "#/definitions/OracleRollableIdWildcard"},
                },
            ],
            title="TagSchema",
        ),
    ]


=======
>>>>>>> upstream/main
MoveCategory.model_rebuild()
NpcCollection.model_rebuild()
AtlasCollection.model_rebuild()
AssetCollection.model_rebuild()
Expansion.model_rebuild()
Rules.model_rebuild()
RulesExpansion.model_rebuild()
TagRule.model_rebuild()
TagSchema7.model_rebuild()
TagSchema8.model_rebuild()
Schema1.model_rebuild()
TagSchema16.model_rebuild()
<<<<<<< HEAD
TagSchema17.model_rebuild()
=======
TagSchema17.model_rebuild()
>>>>>>> upstream/main
